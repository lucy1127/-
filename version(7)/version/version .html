<!DOCTYPE html>
<html>
	<head>
		<style>
			body {
				overflow: hidden
			}
			#heading {
				text-align: center;
				position: absolute;
				width: 100vw;
			}
			#btn {
				position: absolute;
				top: 300px;
			}
			
			#bullet {
				position: absolute;
				top: 10px;
				right: 160px
			}
			#introduction{
				position:absolute;
				text-align: center;
				width: 1300px;
				height: 1100px;
				backdrop-filter: blur(5px);
				z-index: 50;
			}
			#word {
				position:absolute;
				text-align: center;
				top: 130px;
				left: 480px;
				z-index: 99;
			}
			#nextWord{
				position:absolute;
				text-align: center;
				top: 115px;
				left: 450px;
				z-index: 99;
			}
			
			#next{
				position:absolute;
				top: 250px;
				left: 330px;
			}
			#playerPic{
				position:absolute;
				top: 165px;
				left: 5px;
			}
			
			#player{
				position:absolute;
				top: 235px;
				left: 20px;
			}
			#line{
				position:absolute;
				top: 175px;
				left: 70px;
			}
			#updownLR{
				position:absolute;
				top: 160px;
				left: 180px;
			}
			#move{
				position:absolute;
				top: 180px;
				left: 250px;
			}
			#space{
				position:absolute;
				top: 250px;
				left: 170px;
			}
			
			#shoot{
				position:absolute;
				top: 260px;
				left: 260px;
			}
			#ctrl{
				position:absolute;
				top: 170px;
				left: 330px;
			}
			#ctrlWord{
				position:absolute;
				top: 160px;
				left: 335px;
				z-index: 99;
			}
			#complement{
				position:absolute;
				top: 170px;
				left: 380px;
			}
			#shift{
				position:absolute;
				top: 270px;
				left: 330px;
			}
			#shiftWord{
				position:absolute;
				top: 260px;
				left: 330px;
				z-index: 99;
			}
			#aim{
				position:absolute;
				top: 260px;
				left: 380px;
			}
			#startPic{
				position:absolute;
				top: 100px;
				left: 350px;
			}
			#lifebtn {
				position: absolute;
				width: 10px;
				height: 10px;
				text-align: left;
				
			}
			
			#manu {
				display: none;
				width: 400px;
				height: 200px;
				margin-left: 10px;
				background-color: #ffffe0;
				border-radius: 30px;
				text-align: left;
				opacity: 0.5;
			}
			
			#closeBtn {
				margin-left: 320px;
				margin-top : 150px;
			}
			
			

			#start {
				position: absolute;
				top: 200px;
				font-size: 60px;
				width: 100%;
				padding: 5px;
				text-align: center;
				color: #ffff00;
				font-weight:bold;
	
			}
			#end {
				position: absolute;
				top: 200px;
				font-size: 60px;
				width: 100%;
				padding: 5px;
				text-align: center;
				color: #ffff00;
				font-weight:bold;
			}
			#restart {
				position: absolute;
				top: 260px;
				font-size: 60px;
				width: 100%;
				padding: 5px;
				text-align: center;
				color: #ffff00;
				font-weight:bold;
			}
			
			
		</style>
		<link rel="stylesheet" href="hp.css">
		
	</head>
	<body>
		<div id="heading">
			<div id = "introduction">
			
				<img src = "picture/introduction.png" width = "650" height = "550"/>
				<div id = "word">
					<img src = "picture/Flag.png" width = "950" height = "350"/>
					<div id = "next" onclick = "nextButton()">
						<img src = "picture/next.png" width = "100" height = "100"/>
					</div>
				</div>
				<div id = "nextWord" style="display:none">
					<img src = "picture/introWord.png" width = "1000" height = "200"/>
					<div id = "playerPic">
							<img src = "player.png" width = "100" height = "100"/>
					</div>
					<div id = "player">
						<img src = "picture/playerWord.png" width = "300" height = "100"/>
					</div>
					<div id = "line">
						<img src = "picture/line.png" width = "300" height = "150"/>
					</div>
					<div id = "updownLR">
						<img src = "picture/updownLR.png" width = "70" height = "70"/>
					</div>
					<div id = "move">
						<img src = "picture/move.png" width = "250" height = "50"/>
					</div>
					<div id = "space">
						<img src = "picture/space.png" width = "100" height = "70"/>
					</div>
					<div id = "shoot">
						<img src = "picture/shoot.png" width = "250" height = "50"/>
					</div>
					<div id = "ctrl">
						<img src = "picture/ctrl.png" width = "50" height = "50"/>
					</div>
					<div id = "ctrlWord">
						<img src = "picture/ctrlWord.png" width = "200" height = "50"/>
					</div>
					<div id = "complement">
						<img src = "picture/complement.png" width = "200" height = "50"/>
					</div>
					<div id = "shift">
						<img src = "picture/shift.png" width = "50" height = "30"/>
					</div>
					<div id = "shiftWord">
						<img src = "picture/shiftWord.png" width = "200" height = "50"/>
					</div>
					<div id = "aim">
						<img src = "picture/aim.png" width = "200" height = "50"/>
					</div>
					<div id = "startPic" onclick = "startGame()">
						<img src = "picture/start.png" width = "100" height = "50"/>
					</div>
				</div>
			</div>
		</div>
		<div class = "soldier">
					<div class="hpBar_Sol">
						
						
						<div class="hpBox_Sol">
							<div class="hp_Sol"></div>
						</div>
					</div>
					<div id = "heartSol">	
						<script>
							
								
								document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40"> ');
								document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40"> ');
								document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40"> ');
							
						</script>
					</div>
				</div>
		<div id = "bullet">	
			<script>
				document.write('<img src="https://i.imgur.com/2WfaiMG.png" width = "40" height = "50"> ');
				document.write('<img src="https://i.imgur.com/2WfaiMG.png" width = "40" height = "50"> ');
				document.write('<img src="https://i.imgur.com/2WfaiMG.png" width = "40" height = "50"> ');	
			</script>
		</div>
		
		<div id = "btn">
			<p class="lifebtn" onclick= "life()">
				<input
					type="button"
					style="
						width: 50px;
						height: 50px;
						background-image: url('https://i.imgur.com/pyKoKxw.png');						
						background-size: 45px 45px;
					"
				/>
			</p>
		
			<div id="manu">
				<div class = "Cap">
					<div class="hpBar_Cap">
						
						<h2>
							<img src = "capturer.png" width = "40" height = "35"/> 
						</h2>
						<div class="hpBox_Cap">
							<div class="hp_Cap"></div>
						</div>
					</div>
					<div id = "heartCap">	
						<script>
							
								
								document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40"> ');
								document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40"> ');
								document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40"> ');
							
						</script>
					</div>
				</div>
				<div class = "leader">
					<div class="hpBar_Led">
						
						<h2>
							<img src = "leader.png" width = "40" height = "35"/> 
						</h2>
						<div class="hpBox_Led">
							<div class="hp_Led"></div>
						</div>
					</div>
					<div id = "heartLed">	
						<script>
							
								
								document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40"> ');
								document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40"> ');
								document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40"> ');
							
						</script>
					</div>
				</div>
				<div class = "defLeft">
					<div class="hpBar_DefL">
						
						<h2>
							<img src = "defense.png" width = "40" height = "35"/> 
						</h2>
						<div class="hpBox_DefL">
							<div class="hp_DefL"></div>
						</div>
					</div>
					<div id = "heartDefL">	
						<script>
							
								
								document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30"> ');
								document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30"> ');
								document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30"> ');
							
						</script>
					</div>
				</div>
				<div class = "def">
					<div class="hpBar_Def">
						
						<h2>
							<img src = "defense.png" width = "40" height = "35"/> 
						</h2>
						<div class="hpBox_Def">
							<div class="hp_Def"></div>
						</div>
					</div>
					<div id = "heartDef">	
						<script>
							
								
								document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30"> ');
								document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30"> ');
								document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30"> ');
							
						</script>
					</div>
				</div>
				<div class = "defRight">
					<div class="hpBar_DefR">
						
						<h2>
							<img src = "defense.png" width = "40" height = "35"/> 
						</h2>
						<div class="hpBox_DefR">
							<div class="hp_DefR"></div>
						</div>
					</div>
					<div id = "heartDefR">	
						<script>
							
								
								document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30"> ');
								document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30"> ');
								document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30"> ');
							
						</script>
					</div>
				</div>
			</div>
		</div>
			
		
		<script src="life.js"></script>
		<script src="state-machine.js"></script>
		<script src="https://threejs.org/build/three.min.js"></script>
		<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
		<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
	    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    
<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three/build/three.module.js"
		}
	}
</script>
		
		
		<div id="start"></div>
		<div id="end"></div>
		<div id="restart"></div>

<script type="module">
import { MTLLoader } from "https://threejs.org/examples/jsm/loaders/MTLLoader.js";
import { OBJLoader } from "https://threejs.org/examples/jsm/loaders/OBJLoader.js";


import * as THREE from 'three';
import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136/examples/jsm/controls/OrbitControls.js';
import { BasisTextureLoader } from "https://cdn.skypack.dev/three@0.136/examples/jsm/loaders/BasisTextureLoader.js";

(function () {
	Math.clamp = function (val, min, max) {
		return Math.min(Math.max(val, min), max);
	};
})();



class Avatar {
	constructor(pos, mesh) {
		this.pos = pos.clone();
		this.vel = new THREE.Vector3();
		this.force = new THREE.Vector3();
		this.MAXSPEED = 50;
		this.ARRIVAL_R = 30;
		this.nbhd = [];

		this.target = null;
		this.size = 25;
		this.mesh = mesh;
		scene.add(mesh);

		// for orientable agent
		this.angle = 0;
		this.steermode = '';
		this.BRAKING = 0;
	}

	update(dt) {
		//console.log ('in avatar update ...');

		this.accumulateForce();
		this.vel.add(this.force.clone().multiplyScalar(dt));

		// ARRIVAL: velocity modulation
		if (this.target !== null) {
			let diff = this.target.clone().sub(this.pos);
			let dst = diff.length();
			if (dst < this.ARRIVAL_R) {
				this.vel.setLength(dst);
			}
		}

		//Obstacle
		let obs = scene.obstacles;
		// pick the most threatening one
		let theOne = null;
		let dist = 1e10;
		let vhat = this.vel.clone().normalize();
		const REACH = 50;
		const K = 5;
		let perp;
		for (let i = 0; i < obs.length; i++) {
			let point = obs[i].center.clone().sub(this.pos); // c-p
			let proj = point.dot(vhat);
			if (proj > 0 && proj < REACH) {
				perp = new THREE.Vector3();
				perp.subVectors(
					point,
					vhat.clone().setLength(proj)
				);
				let overlap =
					obs[i].size + this.size - perp.length();
				if (overlap > 0 && proj < dist) {
					theOne = obs[i];
					dist = proj;
					perp.setLength(K * overlap);
					perp.negate();
				}
			}
		}
		if (theOne) this.force.add(perp);

		this.vel.add(this.force.clone().multiplyScalar(dt));

		// ARRIVAL: velocity modulation
		if (this.target !== null) {   
			let diff = this.target.clone().sub(this.pos)
			let dst = diff.length();
			if (dst < this.ARRIVAL_R) {
				this.vel.setLength(dst)
			}
		}
					
		// MAXSPEED modulation
		let speed = this.vel.length();
		this.vel.setLength(Math.clamp(speed, 0, this.MAXSPEED));
		this.pos.add(this.vel.clone().multiplyScalar(dt));
		this.mesh.position.copy(this.pos);

		// for orientable agent
		if (this.vel.length() > 2.0) {
			this.angle = Math.atan2(-this.vel.z, this.vel.x);
			this.mesh.rotation.y = this.angle;
		}
	}

	setSeekTarget(x, y, z) {
		this.BRAKING = 0; // release Brake while seek
		this.steerMode = "SEEK";
		this._setTarget(x, y, z);
	}

	// target, Patrol & Hide
	setPatrolTarget(x, y, z) {
		this.BRAKING = 0;
		this.steerMode = "patrol";
		this._setTarget(x, y, z);
	}

	setAttackTarget(x, y, z) {
		this.BRAKING = 0;
		this.steerMode = "attack";
		//this._setTarget (x,y,z);
	}

	setHideTarget(x, y, z) {
		this.BRAKING = 0;
		this.steerMode = "hide";
		this._setTarget(x, y, z);
	}


	setFleeTarget(x, y, z) {
		this.BRAKING = 0;
		this.steerMode = "FLEE";
		this._setTarget(x, y, z);
	}
	setFollowTarget(x, y, z) {
		this.BRAKING = 0;
		this.steerMode = "FOLLOW";
		this._setTarget(x, y, z);
	}

	_setTarget(x, y, z) {
		// do not use directly
		if (this.target !== null) this.target.set(x, y, z);
		else {
			this.target = new THREE.Vector3(x, y, z);
		}
	}

	targetInducedForce(targetPos) {
		let sign = 0;
		if (
			this.steerMode === "patrol" ||
			this.steerMode === "SEEK" ||
			this.steerMode === "FOLLOW"
		)
			sign = 1;
		else if (
			this.steerMode === "hide" ||
			this.steerMode === "FLEE"
		)
			sign = -1;

		return targetPos
			.clone()
			.sub(this.pos)
			.normalize()
			.multiplyScalar(sign * this.MAXSPEED)
			.sub(this.vel);
	}

	setBrake(brake) {
		// make the avatar stop gracefully
		this.BRAKING = brake;
		this.target = null; // release target
	}
	
	distanceTo(otherAgent) {
		return this.pos.distanceTo(otherAgent.pos)
	}
	addNbr(otherAgent) {
		this.nbhd.push(otherAgent)
	}
	
	accumulateForce() {
		if (this.target)
			this.force.copy(this.targetInducedForce(this.target));
		else this.force.set(0, 0, 0); // for null-target initial force

		// braking ...
		this.force.add(
			this.vel.clone().multiplyScalar(-this.BRAKING)
		);
		
		 ////////////////////////////////////////
		// group steer related
		// separation
		let push = new THREE.Vector3()
		for (let i = 0; i < this.nbhd.length; i++) {
			let point = this.pos.clone().sub(this.nbhd[i].pos);
			push.add(point.setLength(40 / point.length()))
		}
		this.force.add(push);
	}
}
class PreditorAgent extends Avatar {
	constructor(pos, mesh, name = "", fsm) {
		super(pos, mesh);
		this.fsm = fsm;
		this.stateSign = null;
	}
	update(dt) {
		super.update(dt); // calling avatar update

		// agent related ...
		// how to make the brain not so hyper-active
		if (this.fsm) {
			$("#preditorState").text(this.fsm.state);

			if (this.fsm.state === "hide") {
				var obstacle = new THREE.Vector3(nearObstacle().center.x,0,nearObstacle().center.z);
				var x =35 * Math.cos((pAngle + p1Angle) / 2) +obstacle.x;
				var z =35 * Math.sin((pAngle + p1Angle) / 2) +obstacle.z;
				
				if (Math.abs(this.pos.x - x) < 1 &&//x是當下要躲藏地點的x座標
					Math.abs(this.pos.z - z) < 1//z是當下要躲藏地點的z座標
					) 
					{
						var angleNow = Math.atan2(x - obstacle.x, z - obstacle.z);
						angleNow -= Math.PI / 2;

						this.mesh.rotation.y = angleNow;
					}
								
				this.mesh.children[0].material.visible = false;
				this.mesh.children[1].material.visible = false;
				this.mesh.children[2].material.visible = true;
				this.mesh.children[3].children[0].material.visible = false;
				if (Math.round(time * 8) % 2 === 0) {
					this.mesh.children[3].children[1].material.visible = true;
					this.mesh.children[3].children[3].material.visible = false;
				}else{
					this.mesh.children[3].children[1].material.visible = false;
					this.mesh.children[3].children[3].material.visible = true;
				}
				this.mesh.children[3].children[2].material.visible = false;
				this.mesh.children[5].material.visible = false;
				this.mesh.children[6].material.visible = false;
				this.mesh.children[7].material.visible = true;
					
			}
			if (this.fsm.state === "patrol") {
				let dt = clock.getElapsedTime();

				if (dt > 8) {
					let back = preditor.mesh.localToWorld(
						new THREE.Vector3(20, 0, -20)
					);
					super.setPatrolTarget(back.x, 0, back.z);
					$("#Check").text("Check Behind");
				} else {
					let dis = prey.mesh.localToWorld(
						new THREE.Vector3(-30, 0, 30)
					);
					super.setPatrolTarget(dis.x, 0, dis.z);
					$("#Check").text("Follow Capturer");
				}
				//console.log(dt);

				this.mesh.children[0].material.visible = true;
				this.mesh.children[1].material.visible = false;
				this.mesh.children[2].material.visible = false;
				this.mesh.children[3].children[0].material.visible = true;
				this.mesh.children[3].children[1].material.visible = false;
				this.mesh.children[3].children[2].material.visible = false;
				this.mesh.children[3].children[3].material.visible = false;
				this.mesh.children[5].material.visible = false;
				this.mesh.children[6].material.visible = true;
				this.mesh.children[7].material.visible = false;
			}
			if (this.fsm.state === "attack") {
				let angle = Math.atan2(soldier.pos.x,0,soldier.pos.z);
				angle -= Math.PI / 2 + Math.PI / 5 ;

				this.mesh.children[3].rotation.y = angle;
			
				
				let pos = soldier.mesh.localToWorld(new THREE.Vector3(-50,0,0));
					super.setSeekTarget(pos.x,0,pos.z);

					this.mesh.children[0].material.visible = false;
					this.mesh.children[1].material.visible = true;
					this.mesh.children[2].material.visible = false;
					this.mesh.children[3].children[0].material.visible = false;
					this.mesh.children[3].children[1].material.visible = false;
					this.mesh.children[3].children[2].material.visible = true;
					this.mesh.children[3].children[3].material.visible = false;
					this.mesh.children[5].material.visible = true;
					this.mesh.children[6].material.visible = false;
					this.mesh.children[7].material.visible = false;
			}
		}
	}
}
class CapturerAgent extends Avatar {
	constructor(pos, mesh, name = "", fsm) {
		super(pos, mesh);
		this.fsm = fsm;
		// initial state got from fsm.state;
		this.stateSign = null;
	}

	update(dt, time) {
		if (this.pos.z >= 200) {
			this.pos.z = 200;
		} else if (this.pos.z <= -200) {
			this.pos.z = -200;
		} else if (this.pos.x >= 200) {
			this.pos.x = 200;
		} else if (this.pos.x <= -200) {
			this.pos.x = -200;
		}
		super.update(dt); // calling avatar update
		if (this.fsm) {
			$("#preyState").text(this.fsm.state);

			if (this.fsm.state === "snatch") {
				super.setSeekTarget(
					flag.position.x,
					0,
					flag.position.z
				);

				if (
					Math.abs(flag.position.x - this.pos.x) < 5 &&
					Math.abs(flag.position.z - this.pos.z) < 5
				) {
					get = true;
					insert = true;
				}
			}
			if (this.fsm.state === "search") {
				var angleSearch, nextTargetX, nextTargetZ;
				var nextTarget, allOk;
				angleSearch = Math.random() * Math.PI * 2;
				nextTarget = this.mesh.localToWorld(
					new THREE.Vector3(
						75 * Math.cos(angleSearch),
						0,
						75 * Math.sin(angleSearch)
					)
				);
				can = false;

				for (var i = 1; i < scene.obstacles.length; i++) {
					if (
						nextTarget.distanceTo(
							scene.obstacles[i].center
						) > scene.obstacles[i].size
					) {
						allOk = true;
					} else {
						allOk = false;
					}
				}
				if (
					nextTarget.x < 190 &&
					nextTarget.x > -190 &&
					nextTarget.z < 190 &&
					nextTarget.z > -190 &&
					allOk === true
				) {
					can = true;
				} else {
					can = false;
					nextTarget = this.mesh.localToWorld(
						new THREE.Vector3(
							75 * Math.cos(angleSearch),
							0,
							75 * Math.sin(angleSearch)
						)
					);
				}

				if (can === true && time < 1) {
					nextTargetCircle.position.set(
						nextTarget.x,
						0,
						nextTarget.z
					);

					super.setSeekTarget(
						nextTarget.x,
						0,
						nextTarget.z
					);
				}
				//super.setBrake(10);
			}

			if (this.fsm.state === "hide") {
				insert = false;
				var obstacle = new THREE.Vector3(
					nearObstacle().center.x,
					0,
					nearObstacle().center.z
				);
				var finalOrientation = new THREE.Quaternion();
				var x =
					35 * Math.cos((pAngle + p1Angle) / 2) +
					obstacle.x;
				var z =
					35 * Math.sin((pAngle + p1Angle) / 2) +
					obstacle.z;
				super.setSeekTarget(x, 0, z);
				if (
					Math.abs(this.pos.x - x) < 1 &&
					Math.abs(this.pos.z - z) < 1
				) {
					//hideTurn = true;

					var angleNow = Math.atan2(
						x - obstacle.x,
						z - obstacle.z
					);
					angleNow -= Math.PI / 2;

					this.mesh.rotation.y = angleNow;
				}
			}
			if (this.fsm.state === "touchDown") {
				if (get === true) {
					flag.position.set(this.pos.x, 10, this.pos.z);
				}
				if (insert === true) {
					super.setSeekTarget(175, 0, 175);
				}
			}
			if (this.fsm.state === "endGame") {
				super.setSeekTarget(-150, 0, -150);
			}
			//hideTurn = false;
		}
		if (this.stateSign) {
			this.stateSign.position.copy(this.pos);
			this.stateSign.position.y = 30;
			//this.stateSign.lookAt(
				//camera.position.x,
				//10,
				//camera.position.z
			//);

			if (this.fsm.state === "snatch") {
				this.stateSign.children[0].material.visible = true;
				this.stateSign.children[1].material.visible = false;
				this.stateSign.children[2].material.visible = false;
				this.stateSign.children[3].material.visible = false;
				nextTargetCircle.material.visible = false;
				this.mesh.children[12].material.visible = false;
				this.mesh.children[1].position.x = 3;
				this.mesh.children[2].material.visible = true;
				this.mesh.children[11].material.visible = true;
				this.mesh.children[6].material.visible = false;
				this.mesh.children[3].material.visible = false;
				this.mesh.children[4].material.visible = false;
				this.mesh.children[5].material.visible = false;
				this.mesh.children[7].material.visible = false;
				this.mesh.children[8].material.visible = false;
				this.mesh.children[9].material.visible = false;
				this.mesh.children[10].material.visible = false;

				this.mesh.children[0].children[0].material.visible = true;
				this.mesh.children[0].children[1].material.visible = false;
				this.mesh.children[0].children[2].material.visible = false;
				this.mesh.children[0].children[3].material.visible = false;
                this.mesh.children[0].children[4].material.visible = false;
			}
			if (this.fsm.state === "search") {
				this.stateSign.children[1].material.visible = true;
				this.stateSign.children[0].material.visible = false;
				this.stateSign.children[2].material.visible = false;
				this.stateSign.children[3].material.visible = false;

				if (time < 1) {
					this.mesh.children[12].material.visible = true;
				} else {
					this.mesh.children[12].material.visible = false;
				}

				if (Math.floor(time) === 2) {
					nextTargetCircle.material.visible = true;
				} else {
					nextTargetCircle.material.visible = false;
				}
				this.mesh.children[1].position.x = 3;
				this.mesh.children[6].material.visible = true;
				this.mesh.children[7].material.visible = true;
				this.mesh.children[3].material.visible = false;
				this.mesh.children[4].material.visible = false;
				this.mesh.children[5].material.visible = false;
				this.mesh.children[2].material.visible = false;
				this.mesh.children[11].material.visible = false;
				this.mesh.children[8].material.visible = false;
				this.mesh.children[9].material.visible = false;
				this.mesh.children[10].material.visible = false;

				this.mesh.children[0].children[3].material.visible = true;
				this.mesh.children[0].children[1].material.visible = false;
				this.mesh.children[0].children[2].material.visible = false;
				this.mesh.children[0].children[0].material.visible = false;
                this.mesh.children[0].children[4].material.visible = false;
			}
			if (this.fsm.state === "hide") {
				this.stateSign.children[2].material.visible = true;
				this.stateSign.children[0].material.visible = false;
				this.stateSign.children[1].material.visible = false;
				this.stateSign.children[3].material.visible = false;
				nextTargetCircle.material.visible = false;
				this.mesh.children[12].material.visible = false;

				if (Math.round(time * 16) % 2 === 0) {
					this.mesh.children[3].material.visible = true;
					this.mesh.children[2].material.visible = false;
					this.mesh.children[0].children[1].material.visible = true;
					this.mesh.children[0].children[0].material.visible = false;
				} else {
					this.mesh.children[2].material.visible = true;
					this.mesh.children[3].material.visible = false;
					this.mesh.children[0].children[1].material.visible = false;
					this.mesh.children[0].children[0].material.visible = true;
				}

				this.mesh.children[1].position.x = 3;
				//this.mesh.children[3].material.visible = true;
				this.mesh.children[8].material.visible = true;
				this.mesh.children[4].material.visible = false;
				//this.mesh.children[2].material.visible = false;
				this.mesh.children[5].material.visible = false;
				this.mesh.children[6].material.visible = false;
				this.mesh.children[11].material.visible = false;
				this.mesh.children[7].material.visible = false;
				this.mesh.children[9].material.visible = false;
				this.mesh.children[10].material.visible = false;

				//this.mesh.children[0].children[1].material.visible = true;
				this.mesh.children[0].children[2].material.visible = false;
				//this.mesh.children[0].children[0].material.visible = false;
				this.mesh.children[0].children[3].material.visible = false;
                this.mesh.children[0].children[4].material.visible = false;
			}
			if (this.fsm.state === "touchDown") {
				this.stateSign.children[3].material.visible = true;
				this.stateSign.children[0].material.visible = false;
				this.stateSign.children[1].material.visible = false;
				this.stateSign.children[2].material.visible = false;
				nextTargetCircle.material.visible = false;
				this.mesh.children[12].material.visible = false;
				if (Math.round(time * 4) % 2 === 0) {
					this.mesh.children[4].material.visible = true;
					this.mesh.children[2].material.visible = false;
					this.mesh.children[0].children[2].material.visible = true;
					this.mesh.children[0].children[0].material.visible = false;
				} else {
					this.mesh.children[2].material.visible = true;
					this.mesh.children[4].material.visible = false;
					this.mesh.children[0].children[2].material.visible = false;
					this.mesh.children[0].children[0].material.visible = true;
				}

				//this.mesh.children[4].material.visible = true;
				this.mesh.children[9].material.visible = true;
				this.mesh.children[3].material.visible = false;
				//this.mesh.children[2].material.visible = false;
				this.mesh.children[5].material.visible = false;
				this.mesh.children[6].material.visible = false;
				this.mesh.children[11].material.visible = false;
				this.mesh.children[7].material.visible = false;
				this.mesh.children[8].material.visible = false;
				this.mesh.children[10].material.visible = false;

				//this.mesh.children[0].children[2].material.visible = true;
				//this.mesh.children[0].children[0].material.visible = false;
				this.mesh.children[0].children[1].material.visible = false;
				this.mesh.children[0].children[3].material.visible = false;
                this.mesh.children[0].children[4].material.visible = false;
			}
			if (this.fsm.state === "endGame") {
				this.stateSign.children[3].material.visible = true;
				this.stateSign.children[0].material.visible = false;
				this.stateSign.children[1].material.visible = false;
				this.stateSign.children[2].material.visible = false;
				nextTargetCircle.material.visible = false;
				this.mesh.children[12].material.visible = false;

				
				this.mesh.children[1].position.x = 3;
				this.mesh.children[5].material.visible = true;
				this.mesh.children[10].material.visible = true;
				this.mesh.children[6].material.visible = false;
				this.mesh.children[3].material.visible = false;
				this.mesh.children[4].material.visible = false;
				this.mesh.children[2].material.visible = false;
				this.mesh.children[7].material.visible = false;
				this.mesh.children[8].material.visible = false;
				this.mesh.children[9].material.visible = false;
				this.mesh.children[11].material.visible = false;

				this.mesh.children[0].children[4].material.visible = true;
                this.mesh.children[0].children[0].material.visible = false;
				this.mesh.children[0].children[1].material.visible = false;
				this.mesh.children[0].children[2].material.visible = false;
				this.mesh.children[0].children[3].material.visible = false;
			}
		}
	}
	/*straight() {
		start = true;
		setTimeout(this.straight(), 5000);
	}*/

	findTarget(target) {
		var point = target.position.clone().sub(this.pos);
		var pointWarrior = soldier.pos
			.clone()
			.sub(this.pos)
			.normalize();

		var preyDirect = this.mesh
			.localToWorld(new THREE.Vector3(1, 0, 0))
			.sub(this.mesh.localToWorld(new THREE.Vector3(0, 0, 0)))
			.normalize();
		var CosineValueWarrior = pointWarrior.dot(preyDirect);

		ray.set(this.pos, pointWarrior);
		//debugger;
		var intersects = ray.intersectObjects(pickables2, true);
		if (intersects.length > 0) {
			if (
				intersects[0].object.name ===
					soldier.mesh.children[3].name &&
				CosineValueWarrior > 0
			) {
				seeWarrior = true;
			} else seeWarrior = false;
		}

		var CosineValue = point.dot(preyDirect);

		if (CosineValue > 0) {
			front = true;
		} else {
			front = false;
		}
	}
}
class DefAgent extends Avatar {
	constructor(pos, mesh, name = "", fsm) {
		super(pos, mesh);
		this.fsm = fsm;
		this.name = name;
		// initial state got from fsm.state;
		this.stateSign = null;
	}

	update(dt) {
		super.update(dt); // calling avatar update
		if (this.fsm) {
			$("#defenseState").text(this.fsm.state);

			if (this.fsm.state === "follow") {
				if (this.name === "defR") {
					let pointfR = prey.mesh.localToWorld(
						new THREE.Vector3(-10, 0, 15)
					);
					super.setFollowTarget(
						pointfR.x,
						pointfR.y,
						pointfR.z
					);

					this.mesh.children[0].material.visible = true;
					this.mesh.children[1].material.visible = false;
				} else if (this.name === "def") {
					let pointf = prey.mesh.localToWorld(
						new THREE.Vector3(-20, 0, 0)
					);
					super.setFollowTarget(
						pointf.x,
						pointf.y,
						pointf.z
					);

					this.mesh.children[0].material.visible = true;
					this.mesh.children[1].material.visible = false;
				} else if (this.name === "defL") {
					let pointfL = prey.mesh.localToWorld(
						new THREE.Vector3(-10, 0, -15)
					);
					super.setFollowTarget(
						pointfL.x,
						pointfL.y,
						pointfL.z
					);
					this.mesh.children[0].material.visible = true;
					this.mesh.children[1].material.visible = false;
				}
			}
			if (this.fsm.state === "defense") {
				if (this.name === "defR") {
					let pointdR = prey.mesh.localToWorld(
						new THREE.Vector3(15, 0, 15)
					);
					super.setFollowTarget(
						pointdR.x,
						pointdR.y,
						pointdR.z
					);

					this.mesh.children[0].material.visible = false;
					this.mesh.children[1].material.visible = true;
				} else if (this.name === "def") {
					let pointd = prey.mesh.localToWorld(
						new THREE.Vector3(-20, 0, 0)
					);
					super.setFollowTarget(
						pointd.x,
						pointd.y,
						pointd.z
					);

					this.mesh.children[0].material.visible = false;
					this.mesh.children[1].material.visible = true;
				} else if (this.name === "defL") {
					let pointdL = prey.mesh.localToWorld(
						new THREE.Vector3(15, 0, -15)
					);
					super.setFollowTarget(
						pointdL.x,
						pointdL.y,
						pointdL.z
					);

					this.mesh.children[0].material.visible = false;
					this.mesh.children[1].material.visible = true;
				}
			}
		}
		
	}
}
class SoldierAgent extends Avatar {
	
	
	constructor(pos, mesh, name = "", fsm) {
		super(pos, mesh);
		this.fsm = fsm;
		this.name = name;
		// initial state got from fsm.state;
		this.stateSign = null;
	}

	update(dt) {
		
		if (this.pos.z >= 195) {
			this.pos.z = 195;
		} else if (this.pos.z <= -195) {
			this.pos.z = -195;
		} else if (this.pos.x >= 195) {
			this.pos.x = 195;
		} else if (this.pos.x <= -195) {
			this.pos.x = -195;
		}
		super.update(dt); 
	}

		findTarget() {
			var pointCapturer = prey.pos
				.clone()
				.sub(this.pos)
				.normalize();

			var soldierDirect = this.mesh
				.localToWorld(new THREE.Vector3(1, 0, 0))
				.sub(this.mesh.localToWorld(new THREE.Vector3(0, 0, 0)))
				.normalize();
			var CosineValueCapturer = pointCapturer.dot(soldierDirect);
			if (CosineValueCapturer > 0) {
				seeCapturer = true;
			} 
			else seeCapturer = false;
		}
	
}
class Obstacle {
    constructor(center, size) {
		this.center = center.clone();
		let loader1 = new BasisTextureLoader();
		loader1.crossOrigin = "";
		let texture1 = loader1.load(
			"https://i.imgur.com/XlAVV7B.jpg"
		);
		texture1.wrapS = THREE.RepeatWrapping;
		texture1.wrapT = THREE.RepeatWrapping;
		texture1.repeat.set(2, 1);
		var texMat1 = new THREE.MeshBasicMaterial({
			map: texture1,
			side: THREE.DoubleSide,
		});
		this.mesh1 = new THREE.Mesh(
		new THREE.CircleGeometry(size, 32),
			texMat1
		);
		this.mesh1.rotation.x = -Math.PI / 2;
		this.mesh1.position.set(center.x, center.y + 10, center.z);
		this.size = size;
		scene.add(this.mesh1);

		let loader = new BasisTextureLoader();
		loader.crossOrigin = "";
		let texture = loader.load(
			"https://i.imgur.com/XlAVV7B.jpg"
		);
		texture.wrapS = THREE.RepeatWrapping;
		texture.wrapT = THREE.RepeatWrapping;
		texture.repeat.set(5, 1);
		var texMat = new THREE.MeshBasicMaterial({
			map: texture,
			side: THREE.DoubleSide,
		});
		this.mesh = new THREE.Mesh(new THREE.CylinderGeometry(size,size,20,64,64,true),texMat);
		this.mesh.position.copy(center);
		this.size = size;
		scene.add(this.mesh);
		this.head = new THREE.Mesh(new THREE.ConeGeometry( size, 20, 64 ),new THREE.MeshPhongMaterial({color : 0x523505,transparent : true,opacity:0.8}))
		this.head.position.set(center.x, center.y + 20, center.z);
		scene.add(this.head);

	}
}

//preditor
var camera,cameraS, scene, renderer, clock,clockShoot;
var preditor, prey, soldier;
var pickables = [];
var raycaster = new THREE.Raycaster();
var mouse = new THREE.Vector2();
var preditorRaycaster,soldierRaycaster;
var theta = 0,
	HH = 12;
var hide = false;
//prey
var keyboard = new KeyboardState();
var ray;
var mouse = new THREE.Vector2();
var pickables2 = [];
var front = false,
	hidden = false;
var count = 0;
var countL = 0;
var flag;
var get = false,
	insert = false,
	endCapturer = false,
	attack = false;
var circleL, circleR;
var pAngle, p1Angle;
var can = false;
var seeWarrior = false,seeCapturer = false;
var nextTargetCircle;
var soldierFlag = false;
var second = 0;
var already = 1;
//defends
var intersects;
var agents = [];
var defenseL, defense, defenseR;
var point;
var stop = false;
var time;
var shooted = false;
//介面
var state = -1;
var start, end, restart;

//蟲洞
var respawnPos,respawnPos1,tunnel,rebir,rebir2;
//tree
var trees = [],trees2 = [],trees3 = [],trees4 = [];
//插旗點
var flagPoint,flagPoint1;
//堡壘
var playerCastle,enemyCastle;
//牌子
var leaderSign,enemySign;
//射擊
var bullets = [],bullets2 = [],solattack,solattack2;
var bulletNum = 0;
//隊長攻擊
var fire,fire1;
var soldierAttack = false;
//生命值
var ATTACK = 50;
var ATTACKS = 50;
var ATTACKL = 50;
var ATTACKDL = 50;
var ATTACKD = 50;
var ATTACKDR = 50;
var Hp = 100;
var HpS = 100;
var HpL = 100;
var HpD = 100;
var HpDL = 100;
var HpDR = 100;
var lifeNum = 3;
var lifeNumL = 3;
var lifeNumS = 3;
var lifeNumD = 3;
var lifeNumDR = 3;
var lifeNumDL = 3;

//視角
var isSwitch = false;
var inHUD = false;

//戰士移動
var movepos = new THREE.Vector3(170,0,170);
var movevel = new THREE.Vector3();
var moveforce = new THREE.Vector3();
var angle,power;

//小視窗
var sceneRTT, cameraTop, renderTarget;
var cameraMap;

//瞄準
var hudCamera,hudScene,zoom = false;

//控制士兵移動
var  moveStop = false;

init();
animate();



function preditorFSM() {
	let fsm = new StateMachine({
		init: "patrol",
		transitions: [
			{ name: "beattacked", from: "patrol", to: "hide" },
			{ name: "beattacked", from: "attack", to: "hide" },
			{ name: "beattacked", from: "hide", to: "hide" },
			{ name: "depart", from: "hide", to: "patrol" },
			{ name: "depart", from: "attack", to: "patrol" },
			{ name: "depart", from: "patrol", to: "patrol" },
			{ name: "shoot", from: "patrol", to: "attack" },
			{ name: "shoot", from: "hide", to: "attack" },
			{ name: "shoot", from: "attack", to: "attack" },
		],
	});
	return fsm;
}
function preyFSM() {
	let fsm = new StateMachine({
		init: "search",
		transitions: [
			{ name: "seeFlag", from: "search", to: "snatch" },
			{ name: "seeFlag", from: "snatch", to: "snatch" },
			{ name: "seeFlag", from: "hide", to: "snatch" },
            { name: "seeFlag", from: "endGame", to: "snatch" },
			//{ name: "findFlag", from: "touchDown", to: "search" },
			{ name: "findFlag", from: "hide", to: "search" },
			{ name: "findFlag", from: "search", to: "search" },
			{ name: "findFlag", from: "endGame", to: "search" },
			{ name: "attacked", from: "snatch", to: "hide" },
			{ name: "attacked", from: "search", to: "hide" },
			{ name: "attacked", from: "touchDown", to: "hide" },
			{ name: "attacked", from: "hide", to: "hide" },
			{ name: "takeFlag", from: "snatch", to: "touchDown" },
			{
				name: "takeFlag",
				from: "touchDown",
				to: "touchDown",
			},
			{ name: "defense", from: "endGame", to: "endGame" },
			{ name: "defense", from: "snatch", to: "endGame" },
			{ name: "defense", from: "search", to: "endGame" },
			{ name: "defense", from: "hide", to: "endGame" },
			{ name: "restart", from: "touchDown", to: "search" },
			{ name: "restart", from: "search", to: "search" },
			{ name: "restart", from: "endGame", to: "search" },
		],
	});
	return fsm;
}
function garrisonFSM() {
	let fsm = new StateMachine({
		init: "follow",
		transitions: [
			{ name: "attack", from: "follow", to: "defense" },
			{ name: "attack", from: "defense", to: "defense" },
			{ name: "noattack", from: "defense", to: "follow" },
			{ name: "noattack", from: "follow", to: "follow" },
		],
	});

	return fsm;
}

function back(){

	let loader = new BasisTextureLoader();
		loader.crossOrigin = "";
		let tex = loader.load(
			"https://i.imgur.com/qoaV6j8.jpg"
		);
	
	let wall = new THREE.Mesh(new THREE.PlaneGeometry(600,300),
				new THREE.MeshBasicMaterial({
					map: tex
					//side: THREE.DoubleSide
				}));
	wall.rotation.y = Math.PI/2;
	wall.position.set(-300,150,0);
	
	
		
	let gt_og = new BasisTextureLoader().load( 'https://i.imgur.com/hyZYHl2.jpg' );
	let gg_og = new THREE.PlaneBufferGeometry( 600, 100 );
	let gm_og = new THREE.MeshBasicMaterial( { color: 0xffffff, map: gt_og ,side: THREE.DoubleSide} );

	let out_ground = new THREE.Mesh( gg_og, gm_og );
	
	out_ground.material.map.repeat.set( 60, 60 );
	out_ground.material.map.wrapS = THREE.RepeatWrapping;
	out_ground.material.map.wrapT = THREE.RepeatWrapping;
	// note that because the ground does not cast a shadow, .castShadow is left false
	out_ground.receiveShadow = true;
	
	out_ground.rotation.x = Math.PI/2;
	out_ground.rotation.z = Math.PI/2;
	out_ground.position.set(-250,0,0);
	
	let bg = new THREE.Group();
	bg.add(wall,out_ground);
	return bg;
	//scene.add(wall,out_ground);
	
}
function tree(){
	let loader = new BasisTextureLoader();
	loader.crossOrigin = '';
	var texture = loader.load('https://i.imgur.com/omX5Drl.png');
	
	var texMat = new THREE.MeshBasicMaterial({
				map: texture,
				//transparent: true
				alphaTest: 0.5
	});
	
	tree = new THREE.Mesh(new THREE.PlaneGeometry(40, 80), texMat);
	
	for (let i = 0; i < 10; i++) {
		let tt = tree.clone();
		tt.position.set (-250, 40, (-1+Math.random()*3)*180)
		trees.push (tt)
		scene.add (tt)
	}
	
	for (let i = 0; i < 10; i++) {
		let tt2 = tree.clone();
		tt2.position.set ((-1+Math.random()*3)*180, 40, -250)
		trees2.push (tt2)
		scene.add (tt2);
	}
	
	for (let i = 0; i < 10; i++) {
		let tt3 = tree.clone();
		tt3.position.set (250, 40, (-1+Math.random()*3)*180)
		trees3.push (tt3)
		scene.add (tt3);
	}
	
	for (let i = 0; i < 10; i++) {
		let tt4 = tree.clone();
		tt4.position.set ((-1+Math.random()*3)*180, 40, 250)
		trees4.push (tt4)
		scene.add (tt4);
	}
}

function gasBox(){
	let loader1 = new BasisTextureLoader();
	loader1.crossOrigin = "";
	let texture1 = loader1.load("https://i.imgur.com/XlAVV7B.jpg");
	texture1.wrapS = THREE.RepeatWrapping;
	texture1.wrapT = THREE.RepeatWrapping;
	texture1.repeat.set(2, 1);
	/*var texMat1 = new THREE.MeshBasicMaterial({
		map: texture1,
		side: THREE.DoubleSide,
	});
	let mesh1 = new THREE.Mesh(new THREE.BoxGeometry(10,20, 5),texMat1);
	mesh1.rotation.x = -Math.PI / 2;*/
	//mesh1.position.set(center.x, center.y + 10, center.z);
	
	
	
	let loader = new BasisTextureLoader();
		loader.crossOrigin = "";
		let texture = loader.load(
			"https://i.imgur.com/ILj85DO.png?1"
		);
	//texture.wrapS = THREE.RepeatWrapping;
	//texture.wrapT = THREE.RepeatWrapping;
	//texture.repeat.set(5, 1);

	var texMat = new THREE.MeshBasicMaterial({
			map: texture,
			side: THREE.DoubleSide,
			alphaTest: 0.5,
	});
	var box1 = new THREE.Mesh(
			new THREE.BoxGeometry(0.1, 30 , 50 ),
			texMat
	);
	//box1.add(mesh1);
	//mesh1.position.y = 15.3;
	var box2 = box1.clone();
	var box3 = box1.clone();
	var box4 = box1.clone();
	var box5 = box1.clone();
	var box6 = box1.clone();
	var box7 = box1.clone();
	//var box8 = box1.clone();
	
	let box = new THREE.Group();
	box.add(box1,box2,box3,box4,box5,box6,box7);
	
	
	box1.position.set(-200,15,180);
	box2.position.set(-200,15,132);
	box3.position.set(-200,15,84);
	box4.position.set(-200,15,38);
	box5.position.set(-200,15,-9);
	box6.position.set(-200,15,-54);
	box7.position.set(-200,15,-101);
	//box8.position.set(-200,15,-128);
	
	return box;
	//scene.add(box);
}

function rebirth(){
	var length_up = 16,width_up = 8;
	var rr_up = 4;
	var shape_up = new THREE.Shape();
	
	shape_up.moveTo(length_up/2,width_up/2);
	shape_up.absarc(0,width_up/2,20,0,Math.PI*2,true);
	
	var holePath_up = new THREE.Path();
	holePath_up.moveTo(length_up/2, width_up/2);
	holePath_up.absarc(0, width_up/2, 15, 0, Math.PI * 2, true);
	shape_up.holes.push(holePath_up);
	
	var extrudeSettings_up = {
	steps: 1,
	depth: 3, // extrude along +Z
	bevelEnabled: false,
  };
	
	let loader = new BasisTextureLoader()
	loader.setCrossOrigin ("")
	let map = loader.load ("https://i.imgur.com/MXNuCwW.png")
	map.wrapS = map.wrapT = THREE.WrapRepeating
	map.repeat.set (.3,.3)
	var geometry = new THREE.ExtrudeGeometry(shape_up,extrudeSettings_up);
	var material = new THREE.MeshBasicMaterial({
		 map: map
	});
	var mesh = new THREE.Mesh(geometry, material);
	//scene.add(mesh);
  
	//mesh.position.set(-2,5,0);
	//mesh.rotation.x = -Math.PI/2;
	return mesh;
}

//守衛
function findNbhd(agents) {
	let i, j, dst;
	let nAgents = agents.length;
  
  // 這樣的 double-for-loop對嗎？
	agents.forEach(function(agent){agent.nbhd=[]});
  
	for (i = 0; i < nAgents - 1; i++) {
		for (j = i + 1; j < nAgents; j++) {
			dst = agents[i].distanceTo(agents[j]);
			if (dst < 30) { // NBHD = 20
				agents[i].addNbr(agents[j]);
				agents[j].addNbr(agents[i]);
			}
		}
	}
}

function castle(){
	var castle = new THREE.Group();
	var square = new THREE.Shape();
	square.moveTo(200,0);
	square.lineTo(200,70);
	square.lineTo(150,70);
	square.lineTo(150,0);
	square.lineTo(200,0);
	
	var hole = new THREE.Path();
	hole.moveTo(160, 0);
	hole.lineTo(160, 35);
	hole.absarc(175,15,15,-Math.PI,Math.PI*2,true);
	hole.lineTo(190, 35);
	hole.lineTo(190, 0);
	hole.lineTo(160, 0);
	
	var hole1 = new THREE.Path();
	hole1.moveTo(155, 40);
	hole1.lineTo(155, 50);
	hole1.lineTo(165, 50);
	hole1.lineTo(165, 40);
	hole1.lineTo(155, 40);
	
	var hole2 = new THREE.Path();
	hole2.moveTo(180, 50);
	hole2.lineTo(180, 60);
	hole2.lineTo(190, 60);
	hole2.lineTo(190, 50);
	hole2.lineTo(180, 50);
	
	square.holes.push(hole,hole1,hole2);
	
	var squareBack = new THREE.Shape();
	squareBack.moveTo(200,0);
	squareBack.lineTo(200,70);
	squareBack.lineTo(150,70);
	squareBack.lineTo(150,0);
	squareBack.lineTo(200,0);
	
	var extrudeSettings = {
		steps: 1,
		depth: 50,
		bevelEnabled: false,
	};
	
	var extrudeSettingsBack = {
		steps: 1,
		depth: 1,
		bevelEnabled: false,
	};
	
	//上面圍欄
	var squareUp = new THREE.Shape();
	squareUp.moveTo(150,70);
	squareUp.lineTo(150,85);
	squareUp.lineTo(158,85);
	squareUp.lineTo(158,75);
	squareUp.lineTo(164,75);
	squareUp.lineTo(164,85);
	squareUp.lineTo(172,85);
	squareUp.lineTo(172,75);
	squareUp.lineTo(178,75);
	
	squareUp.lineTo(178,85);
	squareUp.lineTo(186,85);
	squareUp.lineTo(186,75);
	squareUp.lineTo(192,75);
	squareUp.lineTo(192,85);
	squareUp.lineTo(200,85);
	squareUp.lineTo(200,70);
	squareUp.lineTo(150,70);	//回起點
	
	var extrudeSettingsUp = {
		steps: 1,
		depth: 5,
		bevelEnabled: false,
	};
	
	let loader = new BasisTextureLoader()
	loader.setCrossOrigin ("")
	let map = loader.load ("https://i.imgur.com/QVhD9It.png")
	map.wrapS = map.wrapT = THREE.WrapRepeating
	map.repeat.set (.1,.1);
	var geometry = new THREE.ExtrudeGeometry(square, extrudeSettings);
	var geometryBack = new THREE.ExtrudeGeometry(squareBack, extrudeSettingsBack);
	var geometryUp = new THREE.ExtrudeGeometry(squareUp, extrudeSettingsUp);
	
	var material = new THREE.MeshLambertMaterial({
		color: 0xffffff,map:map
	});
	var materialBack = new THREE.MeshLambertMaterial({
		color: 0xffffff,map:map
	});
	var materialUp = new THREE.MeshLambertMaterial({
		color: 0xffffff,map:map
	});
	
	var mesh = new THREE.Mesh(geometry, material);
	var meshBack = new THREE.Mesh(geometryBack, materialBack);
	
	var fence = new THREE.Group();	//圍欄
	var meshUp = new THREE.Mesh(geometryUp, materialUp);
	var meshUp2 = meshUp.clone();
	meshUp2.position.set(150,0,200);
	meshUp2.rotation.y = Math.PI/2;
	
	var meshUp3 = meshUp.clone();
	meshUp3.position.set(0,0,45);
	
	var meshUp4 = meshUp2.clone();
	meshUp4.position.set(195,0,200);
	fence.add(meshUp,meshUp2,meshUp3,meshUp4);
	castle.add(mesh,meshBack,fence)
	
	//scene.add(castle);	
	return castle;
}
function leaderSignMesh(){
	let loader = new BasisTextureLoader()
	loader.setCrossOrigin ("")
	let map = loader.load ("https://i.imgur.com/PpRsPnV.png")
	
	let geometry = new THREE.CircleGeometry(15, 20);
	let material = new THREE.MeshBasicMaterial({
			map: map,
			transparent: true,
			side: THREE.DoubleSide,
	});
	
	let mesh = new THREE.Mesh(geometry,material);
	
	return mesh;
}
function enemySignMesh(){
	let loader = new BasisTextureLoader()
	loader.setCrossOrigin ("")
	let map = loader.load ("https://i.imgur.com/0zvc7zF.png")
	
	let geometry = new THREE.CircleGeometry(15, 20);
	let material = new THREE.MeshBasicMaterial({
			map: map,
			transparent: true,
			side: THREE.DoubleSide,
	});
	
	let mesh = new THREE.Mesh(geometry,material);
	
	return mesh;
}


function init() {
	clock = new THREE.Clock();
	clockShoot = new THREE.Clock();
	scene = new THREE.Scene();
	camera = new THREE.PerspectiveCamera(
		50,
		window.innerWidth / window.innerHeight,
		1,
		1000
	);

	camera.position.z =100;
	camera.position.y =100;
	


	renderer = new THREE.WebGLRenderer();
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setClearColor(0x888888);
	renderer.autoClear = false;

	let light = new THREE.PointLight(0xffffff);
	light.position.set(100, 300, 200);
	scene.add(light);
	
	
	//介面
	//start = document.getElementById("start");
	//start.innerHTML = "Press enter to begin";

	end = document.getElementById("end");
	restart = document.getElementById("restart");
	

	let controls = new OrbitControls(camera, renderer.domElement);
	document.body.appendChild(renderer.domElement);
	window.addEventListener("resize", onWindowResize, false);
	//////////////////////////////////////////////////////////////////////////////////////////
	// topview camera (for scene)
	cameraTop = new THREE.OrthographicCamera (-200,200,200,-200,-10,1000);
	cameraTop.position.set (0,50,0);
	cameraTop.up.set (0,0,-1);
	cameraTop.lookAt (0,0,0);
  
	// scene for minimap
	// (a plane with RTT-ed topview texture)
  
	sceneRTT = new THREE.Scene();
	renderTarget = new THREE.WebGLRenderTarget(
		1024, 1024, {
		minFilter: THREE.LinearFilter,
		magFilter: THREE.NearestFilter,
		format: THREE.RGBFormat
		}
	);
	// map size: 400x400
	let plane = new THREE.PlaneBufferGeometry(400, 400); 
	let minimap = new THREE.Mesh(plane,
		new THREE.MeshBasicMaterial({
		map: renderTarget.texture,
		side: THREE.DoubleSide,
		transparent: true,
		opacity: 0.8,
		//depthWrite: false,
		//depthTest: false,    
    }));
	sceneRTT.add(minimap);

	// camera for RTT-ed minimap
	cameraMap = new THREE.OrthographicCamera (-200,200,200,-200,-10,100);


	
	//  GROUND

	var loader = new BasisTextureLoader();
	loader.crossOrigin = "";
	var gt2 = loader.load( 'https://i.imgur.com/hyZYHl2.jpg' );
	var gg = new THREE.PlaneBufferGeometry( 400, 400 );
	var gm = new THREE.MeshBasicMaterial( { color: 0xffffff, map: gt2 ,side: THREE.DoubleSide} );

	var ground = new THREE.Mesh( gg, gm );
	ground.rotation.x = - Math.PI / 2;
	ground.material.map.repeat.set( 20, 20 );
	ground.material.map.wrapS = THREE.RepeatWrapping;
	ground.material.map.wrapT = THREE.RepeatWrapping;
	// note that because the ground does not cast a shadow, .castShadow is left false
	ground.receiveShadow = true;
	scene.add(ground);
	

	let grd = new THREE.Group();
	let groundE = new THREE.Mesh(
		new THREE.PlaneGeometry(50, 50, 32),
		new THREE.MeshBasicMaterial({
			color: 0xff0000,
			transparent: true,
			opacity: 0.3,
			side: THREE.DoubleSide,
		})
	);
	
	groundE.rotation.x = Math.PI / 2;
	
	let groundP = groundE.clone();
	
	grd.add(groundE,groundP);
	groundE.position.set(-175,0.5,-175);
	groundP.position.set(175,0.5,175);
	
	scene.add(grd);
	
	
	//background
	let bg_left = back();
	let bg_front = back();
	let bg_right = back();
	let bg_down = back();
	scene.add(bg_left,bg_front,bg_right,bg_down);
	bg_front.rotation.y = -Math.PI/2;
	bg_right.rotation.y = Math.PI;
	bg_down.rotation.y = Math.PI/2;
	
	let box_a = gasBox();	//左
	let box_b = gasBox();	//右
	let box_c = gasBox();	//上
	let box_d = gasBox();	//下
	
	scene.add(box_a,box_b,box_c,box_d);
	
	box_b.position.set(400,0,-75);
	box_c.position.set(0,0,-400);
	box_d.position.set(-75,0,0);
	
	box_c.rotation.y = Math.PI/2;
	box_d.rotation.y = Math.PI/2;
	
	//////////////////////////////////////////////////////////////////////////////////////////
	////蟲洞//////
	rebir = rebirth();
	rebir2 = rebir.clone();
	rebir.rotation.y = Math.PI/2;
	rebir2.rotation.y = Math.PI/2;
	
	scene.add(rebir,rebir2);
	rebir.position.set(-195,25,-170);
	rebir2.position.set(195,25,170)
	
	tree();
	
	
	

	//////////////////////////////////////////////////////////////////////////////////////////
	playerCastle = castle();
	playerCastle.rotation.y = -Math.PI/2;
	
	playerCastle.position.x = 250;
	
	leaderSign = leaderSignMesh();
	leaderSign.position.set(225,100,175);
	
	enemyCastle = castle();
	enemyCastle.rotation.y = Math.PI/2;
	enemyCastle.position.x = -250;
	
	enemySign = enemySignMesh();
	enemySign.position.set(-225,100,-175);
	
	flagPoint = new THREE.Mesh(
		new THREE.CircleGeometry(6, 32),
		new THREE.MeshBasicMaterial({
			color: "red",
			side: THREE.DoubleSide,
		})
	);
	flagPoint.rotation.x = -Math.PI / 2;

	flagPoint.position.set(-175, 1, -175);

	flagPoint1 = flagPoint.clone();
	flagPoint1.position.set(175, 1, 175);
	scene.add(
		playerCastle,leaderSign,
		enemyCastle,enemySign,
		flagPoint,
		flagPoint1
	);
	//////////////////////////////////////////////////////////////////////////////////////////
	preditor = new PreditorAgent(
		new THREE.Vector3(-175, 0, -175),
		preditorMesh(),
		"T-Rex",
		preditorFSM()
	);
	
	prey = new CapturerAgent(
		new THREE.Vector3(190, 20, -170),
		capturerMesh(),
		"sheep",
		preyFSM()
	);
	prey.stateSign = stateSign();

	soldier = new SoldierAgent(
		new THREE.Vector3(170, 0, 170),
		soldierMesh(),
		"soldier"
	);
	


	

	let defmeshR = DefMesh();
	let defmesh = DefMesh();
	let defmeshL = DefMesh();
	defenseR = new DefAgent(
		new THREE.Vector3(-175, 0, -175),
		defmeshR,
		"defR",
		garrisonFSM()
	);
	defense = new DefAgent(
		new THREE.Vector3(-175, 0, -175),
		defmesh,
		"def",
		garrisonFSM()
	);
	defenseL = new DefAgent(
		new THREE.Vector3(-175, 0, -175),
		defmeshL,
		"defL",
		garrisonFSM()
	);
	agents.push(defenseL, defense, defenseR, prey);
	

	preditorRaycaster = new THREE.Raycaster();
	raycaster = new THREE.Raycaster();
	ray = new THREE.Raycaster();
	soldierRaycaster = new THREE.Raycaster();

	//flag
	let loader2 = new BasisTextureLoader();
	loader2.crossOrigin = "";
	let tex = loader2.load("https://i.imgur.com/3YSMhL0.png");
	flag = new THREE.Mesh(
		new THREE.CircleGeometry(15, 20),
		new THREE.MeshBasicMaterial({
			map: tex,
			transparent: true,
			side: THREE.DoubleSide,
		})
	);
	var x = Math.random() * 380 - 190;
	flag.position.set(x, 8, -x);

	scene.add(flag);
	flag.name = "flag";
	//pickables2.push(flag);
	
	
	
	scene.obstacles = [];
	scene.obstacles.push(
		new Obstacle(new THREE.Vector3(20, 0, 50), 15)
	);
	scene.obstacles.push(
		new Obstacle(new THREE.Vector3(-40, 0, -100), 15)
	);
	scene.obstacles.push(
		new Obstacle(new THREE.Vector3(-100, 0, 50), 15)
	);
	scene.obstacles.push(
		new Obstacle(new THREE.Vector3(80, 0, -120), 15)
	);
	scene.obstacles.push(
		new Obstacle(new THREE.Vector3(100, 0, 0), 15)
	);
	scene.obstacles[0].mesh.name = "obstacles";
	scene.obstacles[1].mesh.name = "obstacles";
	scene.obstacles[2].mesh.name = "obstacles";
	scene.obstacles[3].mesh.name = "obstacles";
	scene.obstacles[4].mesh.name = "obstacles";
	pickables2.push(
		flag,
		scene.obstacles[0].mesh,
		scene.obstacles[1].mesh,
		scene.obstacles[2].mesh,
		scene.obstacles[3].mesh,
		scene.obstacles[4].mesh,
		soldier.mesh.children[3]
	);
	///////////////////////////////////////////////////////////

	nextTargetCircle = new THREE.Mesh(
		new THREE.CircleGeometry(3, 20),
		new THREE.MeshBasicMaterial({ color: "black" })
	);
	scene.add(nextTargetCircle);
	nextTargetCircle.rotation.x = -Math.PI / 2;
	nextTargetCircle.position.set(2000, 0, 0);
	
	//戰士移動
	power = 5.0;
	angle = 0.0;
	
	hudScene = new THREE.Scene();
	hudScene.add (new THREE.Mesh (new THREE.RingGeometry(12,15,30), new THREE.MeshBasicMaterial({color:'black'})));
	hudScene.add (makeCross());
	hudCamera = new THREE.OrthographicCamera (-20,20,20,-20,-10,10);
	
}
function DefMesh() {
	let loader = new BasisTextureLoader();
	let icon = loader.load("https://i.imgur.com/iiq8Wk5.png");

	let loaderBody = new BasisTextureLoader();
	let iconBody = loader.load("https://i.imgur.com/iiq8Wk5.png");
	iconBody.wrapS = THREE.RepeatWrapping;
	iconBody.wrapT = THREE.RepeatWrapping;
	iconBody.repeat.set(5, 1);

	var def = new THREE.Group();
	var mat = new THREE.MeshNormalMaterial();

	var body = new THREE.Mesh(
		new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
		new THREE.MeshBasicMaterial({ 
			color: "lightgreen",
			map: iconBody,
			side: THREE.DoubleSide,
		})
	);
	var body2 = new THREE.Mesh(
		new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
		new THREE.MeshBasicMaterial({ 
			color: "red",
			map: iconBody,
			side: THREE.DoubleSide,
		})
	);


	var pointer = new THREE.Mesh(
		new THREE.BoxGeometry(15, 2, 2),
		mat
	);
	body.position.y = 2;
	body2.position.y = 2;
	pointer.position.set(5, 2, 0);

	// '卒'蓋
	let iconZX = new THREE.Group();
	let circle = new THREE.Mesh(
		new THREE.CircleGeometry(8, 32),
		new THREE.MeshBasicMaterial({ map: icon })
	);
	circle.position.y = 4;
	circle.rotation.x = -Math.PI / 2;
	iconZX.add(circle);

	def.add(body, body2, iconZX, pointer);
	return def;
}

function soldierMesh() {
	let loader = new BasisTextureLoader();
	let icon = loader.load("https://i.imgur.com/C8sduKF.png");
	let loaderBody = new BasisTextureLoader();
	let iconBody = loader.load("https://i.imgur.com/7yl0PLz.png");
	iconBody.wrapS = THREE.RepeatWrapping;
	iconBody.wrapT = THREE.RepeatWrapping;
	iconBody.repeat.set(5, 1);
	var body = new THREE.Mesh(
        new THREE.CylinderGeometry(8, 8, 4, 32, 1, true),
        new THREE.MeshBasicMaterial({
            map: iconBody,
            side: THREE.DoubleSide,
        })
	);
	var soldier = new THREE.Group();
	var mat = loader.load("https://i.imgur.com/7vbarnJ.jpeg");
	var pointerHeadTexture = loader.load(
	   "https://i.imgur.com/93FViDI.png"
	);

	var pointer = new THREE.Mesh(
        new THREE.CylinderGeometry(1.5, 1.5, 15, 32),
        new THREE.MeshBasicMaterial({
        map: mat,
        side: THREE.DoubleSide,
        })
	);
	var pointerHead = new THREE.Mesh(
        new THREE.CylinderGeometry(1.7, 1.7, 2, 32, 1, true),
        new THREE.MeshBasicMaterial({
        map: pointerHeadTexture,
        side: THREE.DoubleSide,
        })
	);
	body.position.y = 2;
    body.name = "soldierBody";
	pointer.rotation.z = Math.PI / 2;
	pointerHead.rotation.z = Math.PI / 2;
	pointerHead.position.set(15, 2, 0);
	pointer.position.set(7, 2, 0);

	// '帥'蓋
	let iconZX = new THREE.Group();
	let circle = new THREE.Mesh(
	new THREE.CircleGeometry(8, 128),
	new THREE.MeshBasicMaterial({ map: icon })
	);
	circle.position.y = 4;
	circle.rotation.x = -Math.PI / 2;
	iconZX.add(circle);
	
	solattack = new THREE.Object3D();
	solattack.position.set(13,2,0);
	solattack2 = new THREE.Object3D();
	solattack2.position.set(12,2,0);

	soldier.add(iconZX, pointer,pointerHead,body,solattack,solattack2);
	return soldier;
}
function preditorMesh() {
	let loader = new BasisTextureLoader();
	let icon = loader.load("https://i.imgur.com/9N9ohZ9.jpeg");
	let loaderBody = new BasisTextureLoader();
	let iconBody = loader.load("https://i.imgur.com/9N9ohZ9.jpeg");
	iconBody.wrapS = THREE.RepeatWrapping;
	iconBody.wrapT = THREE.RepeatWrapping;
	iconBody.repeat.set(5, 1);


	var mat = loader.load("https://i.imgur.com/7vbarnJ.jpeg");
	var pointerHeadTexture = loader.load("https://i.imgur.com/93FViDI.png");

	var captain = new THREE.Group();
	var body = new THREE.Mesh(
	new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
	new THREE.MeshBasicMaterial({
	color:"green",
	map: iconBody,
	side: THREE.DoubleSide,
	})
	);
	var body2 = new THREE.Mesh(
	new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
	new THREE.MeshBasicMaterial({
	color:"red",
	map: iconBody,
	side: THREE.DoubleSide,
	})
	);
	var body3 = new THREE.Mesh(
	new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
	new THREE.MeshBasicMaterial({
	color:"yellow",
	map: iconBody,
	side: THREE.DoubleSide,
	})
	);
	var pointer = new THREE.Mesh(
	new THREE.CylinderGeometry(1.5, 1.5,15,32),
	new THREE.MeshBasicMaterial({
	map: mat,
	side: THREE.DoubleSide
	})
	);
	var pointerHead = new THREE.Mesh(
	new THREE.CylinderGeometry(1.7,1.7,2,32,1,true),
	new THREE.MeshBasicMaterial({
	color:"red",
	side: THREE.DoubleSide
	})
	);

	var pointerHead2 = new THREE.Mesh(
	new THREE.CylinderGeometry(1.7,1.7,2,32,1,true),
	new THREE.MeshBasicMaterial({
	color:'green',
	side: THREE.DoubleSide,
	})
	);
	var pointerHead3 = new THREE.Mesh(
	new THREE.CylinderGeometry(1.7,1.7,2,32,1,true),
	new THREE.MeshBasicMaterial({
	color:"yellow",
	side: THREE.DoubleSide,
	})
	);

	body.position.y = 3;
	body2.position.y = 3;
	body3.position.y = 3;
	body.name = "preditor";
	body2.name = "preditor1";
	body3.name = "preditor2";


	pointer.rotation.z = Math.PI/2;
	pointer.position.set(5, 2, 0);
	pointerHead.rotation.z = Math.PI/2;
	pointerHead.position.set(13,2,0);
	pointerHead2.rotation.z = Math.PI/2;
	pointerHead2.position.set(13,2,0);
	pointerHead3.rotation.z = Math.PI/2;
	pointerHead3.position.set(13,2,0);


	// '帥'蓋
	let iconZX = new THREE.Group();
	let circle = new THREE.Mesh(
	new THREE.CircleGeometry(8, 32),
	new THREE.MeshBasicMaterial({ color:'green', map: icon ,side: THREE.DoubleSide})
	);
	let circle2 = new THREE.Mesh(
	new THREE.CircleGeometry(8, 32),
	new THREE.MeshBasicMaterial({ color:'yellow', map: icon,side: THREE.DoubleSide })
	);
	let circle3 = new THREE.Mesh(
	new THREE.CircleGeometry(8, 32),
	new THREE.MeshBasicMaterial({ color:'red', map: icon,side: THREE.DoubleSide})
	);
	let circleback = new THREE.Mesh(
	new THREE.CircleGeometry(8, 32),
	new THREE.MeshBasicMaterial({ color:'grey', map: icon,side: THREE.DoubleSide})
	);

	circle.position.y = 5;
	circle.rotation.x = -Math.PI / 2;
	circle2.position.y = 5;
	circle2.rotation.x = -Math.PI / 2;
	circle3.position.y = 5;
	circle3.rotation.x = -Math.PI / 2;
	circleback.position.y = 5;
	circleback.rotation.x = -Math.PI / 2;
	iconZX.add(circle,circle2,circle3,circleback);

	fire = new THREE.Object3D();
	fire.position.set(12, 2, 0);
	fire1 = new THREE.Object3D();
	fire1.position.set(11, 2, 0);

	captain.add(body, body2,body3, iconZX, pointer,pointerHead,pointerHead2,pointerHead3,fire,fire1);
	return captain;
}
function capturerMesh() {
	let loader = new BasisTextureLoader();
	let icon = loader.load("https://i.imgur.com/MIvqfLQ.png");

	let loaderBody = new BasisTextureLoader();
	let iconBody = loader.load("https://i.imgur.com/MIvqfLQ.png");
	iconBody.wrapS = THREE.RepeatWrapping;
	iconBody.wrapT = THREE.RepeatWrapping;
	iconBody.repeat.set(5, 1);

	var capturer = new THREE.Group();
	var mat = new THREE.MeshNormalMaterial();
	var body = new THREE.Mesh(
		new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
		new THREE.MeshBasicMaterial({
			color: "lightgreen",
			map: iconBody,
			side: THREE.DoubleSide,
		}) //snatch
	);
	var body2 = new THREE.Mesh(
		new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
		new THREE.MeshBasicMaterial({
			color: "yellow",
			map: iconBody,
			side: THREE.DoubleSide,
		}) //hide
	);
	var body3 = new THREE.Mesh(
		new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
		new THREE.MeshBasicMaterial({
			color: "blue",
			map: iconBody,
			side: THREE.DoubleSide,
		}) //touchDown
	);
	var body4 = new THREE.Mesh(
		new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
		new THREE.MeshBasicMaterial({
			color: "red",
			map: iconBody,
			side: THREE.DoubleSide,
		}) //endDown
	);
	var body5 = new THREE.Mesh(
		new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
		new THREE.MeshBasicMaterial({
			color: "green",
			map: iconBody,
			side: THREE.DoubleSide,
		}) //search
	);

	var pointer = new THREE.Mesh(
		new THREE.CylinderGeometry(1.5, 1.5, 15, 20, 1),
		mat
	);
	var pbody = new THREE.Mesh(
		new THREE.CylinderGeometry(1.6, 1.6, 1.5, 20, 1, true),
		new THREE.MeshBasicMaterial({
			color: "lightgreen",
			side: THREE.DoubleSide,
		})
	);
	var pbody2 = new THREE.Mesh(
		new THREE.CylinderGeometry(1.6, 1.6, 1.5, 20, 1, true),
		new THREE.MeshBasicMaterial({
			color: "yellow",
			side: THREE.DoubleSide,
		})
	);
	var pbody3 = new THREE.Mesh(
		new THREE.CylinderGeometry(1.6, 1.6, 1.5, 20, 1, true),
		new THREE.MeshBasicMaterial({
			color: "blue",
			side: THREE.DoubleSide,
		})
	);
	var pbody4 = new THREE.Mesh(
		new THREE.CylinderGeometry(1.6, 1.6, 1.5, 20, 1, true),
		new THREE.MeshBasicMaterial({
			color: "red",
			side: THREE.DoubleSide,
		})
	);
	var pbody5 = new THREE.Mesh(
		new THREE.CylinderGeometry(1.6, 1.6, 1.5, 20, 1, true),
		new THREE.MeshBasicMaterial({
			color: "0x1ad450",
			side: THREE.DoubleSide,
		})
	);

	var searchCircle = new THREE.Mesh(
		new THREE.CircleGeometry(75, 32),
		new THREE.MeshBasicMaterial({
			color: "pink",
			transparent: true,
			opacity: 0.4,
			side: THREE.DoubleSide,
		})
	);
	searchCircle.rotation.x = -Math.PI / 2;	
	searchCircle.position.y = 1;	

	pbody.position.set(11, 2, 0);
	pbody.rotation.z = Math.PI / 2;
	pbody2.position.set(11, 2, 0);
	pbody2.rotation.z = Math.PI / 2;
	pbody3.position.set(11, 2, 0);
	pbody3.rotation.z = Math.PI / 2;
	pbody4.position.set(11, 2, 0);
	pbody4.rotation.z = Math.PI / 2;
	pbody5.position.set(11, 2, 0);
	pbody5.rotation.z = Math.PI / 2;
	body.position.y = 2;
	body2.position.y = 2;
	body3.position.y = 2;
	body4.position.y = 2;
	body5.position.y = 2;
	pointer.position.set(5, 2, 0);
	pointer.rotation.z = Math.PI / 2;

	// '車'蓋
	let iconZX = new THREE.Group();
	let circle = new THREE.Mesh(
		new THREE.CircleGeometry(8, 8),
		new THREE.MeshBasicMaterial({
			map: icon,
			color: "lightgreen",
			side: THREE.DoubleSide,
		}) //snatch
	);
	circle.position.y = 4;
	circle.rotation.x = -Math.PI / 2;
	let circle2 = new THREE.Mesh(
		new THREE.CircleGeometry(8, 8),
		new THREE.MeshBasicMaterial({
			map: icon,
			color: "yellow",
			side: THREE.DoubleSide,
		}) //hide
	);
	circle2.position.y = 4;
	circle2.rotation.x = -Math.PI / 2;
	let circle3 = new THREE.Mesh(
		new THREE.CircleGeometry(8, 8),
		new THREE.MeshBasicMaterial({
			map: icon,
			color: "blue",
			side: THREE.DoubleSide,
		}) //touchDown
	);
	circle3.position.y = 4;
	circle3.rotation.x = -Math.PI / 2;
	let circle4 = new THREE.Mesh(
		new THREE.CircleGeometry(8, 8),
		new THREE.MeshBasicMaterial({
			map: icon,
			color: 0x1ad450,
			side: THREE.DoubleSide,
		}) //touchDown
	);
	circle4.position.y = 4;
	circle4.rotation.x = -Math.PI / 2;
    let circle5 = new THREE.Mesh(
		new THREE.CircleGeometry(8, 8),
		new THREE.MeshBasicMaterial({
			map: icon,
			color: "red",
			side: THREE.DoubleSide,
		}) //endGame
	);
	circle5.position.y = 4;
	circle5.rotation.x = -Math.PI / 2;
	iconZX.add(circle, circle2, circle3, circle4,circle5);

	capturer.add(
		iconZX,
		pointer,
		body,
		body2,
		body3,
		body4,
		body5,
		pbody,
		pbody2,
		pbody3,
		pbody4,
		pbody5,
		searchCircle
	);
	return capturer;
}
function stateSign() {
	let loader = new BasisTextureLoader();
	let snatchMap = loader.load("https://i.imgur.com/L67LiqY.png");
	let searchMap = loader.load("https://i.imgur.com/ui0cEeC.png");
	let hideMap = loader.load("https://i.imgur.com/BRChBw1.png");
	let touchDownMap = loader.load(
		"https://i.imgur.com/lJ95E9L.png"
	);
	let snatchMesh = new THREE.Mesh(
		new THREE.PlaneGeometry(35, 30),
		new THREE.MeshBasicMaterial({
			map: snatchMap,
			transparent: true,
			alphaTest: 0,
			side: THREE.DoubleSide,
		})
	);
	let searchMesh = new THREE.Mesh(
		new THREE.PlaneGeometry(35, 20),
		new THREE.MeshBasicMaterial({
			map: searchMap,
			transparent: true,
			alphaTest: 0,
			side: THREE.DoubleSide,
		})
	);
	let hideMesh = new THREE.Mesh(
		new THREE.PlaneGeometry(35, 30),
		new THREE.MeshBasicMaterial({
			map: hideMap,
			transparent: true,
			alphaTest: 0,
			side: THREE.DoubleSide,
		})
	);
	let touchDownMesh = new THREE.Mesh(
		new THREE.PlaneGeometry(50, 30),
		new THREE.MeshBasicMaterial({
			map: touchDownMap,
			transparent: true,
			alphaTest: 0,
			side: THREE.DoubleSide,
		})
	);
	let preyStateSign = new THREE.Group();
	preyStateSign.add(
		snatchMesh,
		searchMesh,
		hideMesh,
		touchDownMesh
	);
	return preyStateSign;
}
function onDocumentMouseDown(event) {
	event.preventDefault();
	mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
	mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

	raycaster.setFromCamera(mouse, camera);

	var intersects = raycaster.intersectObjects(pickables);
	if (intersects.length > 0) {
		//target.position.copy(intersects[0].point);
		flag.position.copy(intersects[0].point);
		flag.position.y = 8;
	}
}
function sight(dst) {
	if (dst < 150 && front === true) {
		prey.fsm.seeFlag();
	}
	if (dst >= 150 && front === false) {
		prey.fsm.findFlag();
	}
}
function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}
function checkRaycaster() {
	let dt = clock.getElapsedTime();
	let preditorToTarget = soldier.pos.clone().sub(preditor.pos);
	let preditorDir = preditor.mesh.localToWorld(new THREE.Vector3(1, 0, 0)).sub(preditor.mesh.localToWorld(new THREE.Vector3(0, 0, 0))).normalize();

	preditorRaycaster.set(preditor.pos, preditorDir);
		
	let intersects = soldierRaycaster.intersectObjects(
		pickables,
		true
	);
	
	let c = new THREE.Mesh();
	c.position.set(nearObstacle().mesh.position.x,0,nearObstacle().mesh.position.z);
	
	if (intersects.length > 0) {
		if (intersects[0].object.name == preditor.mesh.children[0].name || intersects[0].object.name == preditor.mesh.children[1].name || intersects[0].object.name == preditor.mesh.children[2].name) 
			hide = false;
		else 
			hide = true;
	}
	let dis = preditor.pos.distanceTo(soldier.pos);

	if (preditorToTarget.dot(preditorDir) < 60 && preditorToTarget.dot(preditorDir) > 20 && dis < 70 && soldierAttack ==  true){
		let p = findP(c);
		findP(c);
		findP1(c);
		findHidePlace(c, p);
		preditor.fsm.beattacked();
		preditor.setSeekTarget(30 * Math.cos((pAngle + p1Angle) / 2) +nearObstacle().center.x,0,30 * Math.sin((pAngle + p1Angle) / 2) +nearObstacle().center.z);
		clock.elapsedTime = 0;
		hide = true;
	}
	if(preditorToTarget.dot(preditorDir) > 0 && soldierAttack ==  false && dis < 70){
		preditor.fsm.shoot();
		LeaderShooting();
	}
	else {
		if(hide == true && dt > 5){
			preditor.fsm.depart();
			hide = false;
		}
	}
}
function LeaderShooting() {
		let timeL = clockShoot.getElapsedTime();
		countL = countL + 1;
		if(countL <2){
				const geometry = new THREE.SphereGeometry( 2, 32, 32 );
				const material = new THREE.MeshBasicMaterial({color : "yellow"});
				let bullet2 = new THREE.Mesh( geometry, material );
					fire.getWorldPosition(bullet2.position);

				let point = new THREE.Vector3();
					fire1.getWorldPosition(point);

				scene.add(bullet2);

				let direction = bullet2.position.clone().sub(point).normalize(); //創造方向

				bullets2.push({
					bullet2: bullet2,
					direction: direction,
				});
				clockShoot.elapsedTime = 0;
				//countL = 0;
		}
		if(timeL > 1 && countL > 1)
			countL = 0;
		
		
}

function randomPosZX(min, max) {
	let x = min + (max - min) * Math.random();
	let z = min + (max - min) * Math.random();

	return new THREE.Vector3(x, 0, z); //x,0,z);
}
function findDis(a, b) {
	return a.pos.distanceTo(b.position);
}


function nearObstacle() {
	var minDis = findDis(prey, scene.obstacles[0].mesh);
	var minNum = 0;

	for (var i = 1; i < scene.obstacles.length; i++) {
		var dis = findDis(prey, scene.obstacles[i].mesh);
		if (dis < minDis) {
			minDis = dis;
			minNum = i;
		}
	}
	return scene.obstacles[minNum];
}

function nearObstacleSold() {
	var minDis = findDis(soldier, scene.obstacles[0].mesh);
	var minNum = 0;

	for (var i = 1; i < scene.obstacles.length; i++) {
		var dis = findDis(soldier, scene.obstacles[i].mesh);
		if (dis < minDis) {
			minDis = dis;
			minNum = i;
		}
	}
	return scene.obstacles[minNum];
}

function findP(c) {
	var axis = new THREE.Vector3(0, 1, 0);
	var cp = new THREE.Vector3();
	var csDis = c.position.distanceTo(soldier.pos);
	var theta;
	var r = nearObstacle().size;
	theta = Math.acos(r / csDis);
	var cs = new THREE.Vector3();
	cs.subVectors(c.position, soldier.pos);
	cp = cs.setLength(r);
	cp.applyAxisAngle(axis, theta);
	var p = new THREE.Vector3();
	p.subVectors(c.position, cp);

	/*circleL.rotation.x = -Math.PI / 2;
	circleL.position.set(p.x, 0, p.z);*/
	return p;
}
function findP1(c) {
	var axis = new THREE.Vector3(0, 1, 0);
	var cp1 = new THREE.Vector3();
	var csDis = c.position.distanceTo(soldier.pos);
	var theta;
	var r = nearObstacle().size;
	theta = Math.acos(r / csDis);
	var cs = new THREE.Vector3();
	cs.subVectors(c.position, soldier.pos);
	cp1 = cs.setLength(r);
	cp1.applyAxisAngle(axis, -theta);
	var p1 = new THREE.Vector3();
	p1.subVectors(c.position, cp1);

	/*circleR.rotation.x = -Math.PI / 2;
	circleR.position.set(p1.x, 0, p1.z);*/
	return p1;
}
function findHidePlace(c, p) {
	var alpha, theta;
	var csDis = c.position.distanceTo(soldier.pos);
	var r = nearObstacle().size;
	theta = Math.acos(r / csDis);
	var psDis = p.distanceTo(soldier.pos);

	var cs = new THREE.Vector3();
	cs.subVectors(c.position, soldier.pos);

	alpha = Math.atan2(cs.z, cs.x);
	pAngle = alpha + theta;
	p1Angle = alpha - theta;
	if (pAngle < 0) {
		pAngle + 2 * Math.PI;
	}
	if (p1Angle < 0) {
		p1Angle + 2 * Math.PI;
	}
}
setInterval(function () {
	clock.elapsedTime = 0;
	//count = Math.random();
}, Math.random() * 1000 + 5000);
setInterval(function () {
	//console.log(second);
	if (already > -1) second = 0;
	else second += 1;
}, 1000);


function loadCubemap() {
	var urls = [
		"https://i.imgur.com/BTTaDij.png", //posx
		"https://i.imgur.com/OkJtYZc.png", //negx
		"https://i.imgur.com/0tGuYpX.png", //posy
		"https://i.imgur.com/TC89KdS.png", //negy
		"https://i.imgur.com/nlwQLOA.png", //posz
		"https://i.imgur.com/7vvbkjE.png", //negz
	];
	var loader = new THREE.CubeTextureLoader();
	loader.setCrossOrigin("");
	var cubeMap = loader.load(urls);
	cubeMap.format = THREE.RGBFormat;
	return cubeMap;
}

/////瞄準
function makeCross() {
	let cross = new THREE.Group();

	let points = [
		new THREE.Vector3(-12, 0, 0),
		new THREE.Vector3(12, 0, 0)
	];

	let geometry0 = new THREE.BufferGeometry();
	geometry0.setFromPoints(points);
	let line0 = new THREE.Line(
		geometry0,
		new THREE.LineBasicMaterial({ color: "black" })
	);

	points = [
		new THREE.Vector3(0, -12, 0),
		new THREE.Vector3(0, 12, 0)
	];

	let geometry1 = new THREE.BufferGeometry();
	geometry1.setFromPoints(points);
	let line1 = new THREE.Line(
		geometry1,
		new THREE.LineBasicMaterial({ color: "black" })
	);

	cross.add(line0, line1);
	return cross;
}


/////士兵射擊
function SoldierShooting(){
	if(keyboard.down('ctrl')){
		document.getElementById("bullet").innerHTML = '<img src="https://i.imgur.com/2WfaiMG.png" width = "40" height = "50"> <img src="https://i.imgur.com/2WfaiMG.png" width = "40" height = "50"> <img src="https://i.imgur.com/2WfaiMG.png" width = "40" height = "50">';
		bulletNum = 0;
	}
	if(keyboard.down('space') && bulletNum < 3){
		
		count = 0; 
		count = count + 1;
		bulletNum += 1;
		if(count < 2){
			const geometry = new THREE.SphereGeometry( 2, 32, 32 );
			const material = new THREE.MeshBasicMaterial({color : "yellow"});
			let bullet = new THREE.Mesh( geometry, material );
				solattack.getWorldPosition(bullet.position);

			let point = new THREE.Vector3();
				solattack2.getWorldPosition(point);

			scene.add(bullet);

			let direction = bullet.position.clone().sub(point).normalize(); //創造方向

			bullets.push({
				bullet: bullet,
				direction: direction,
			});
		}
		if(bulletNum == 1){
			document.getElementById("bullet").innerHTML = '<img src="https://i.imgur.com/2WfaiMG.png" width = "40" height = "50"> <img src="https://i.imgur.com/2WfaiMG.png" width = "40" height = "50">';
		}
		else if(bulletNum == 2){
			document.getElementById("bullet").innerHTML = '<img src="https://i.imgur.com/2WfaiMG.png" width = "40" height = "50">';
		}
		else if(bulletNum == 3){
			document.getElementById("bullet").innerHTML = 'No Bullet!';
		}
	}
	
	
}

////射擊
function ShootThrough() {

let x = -1,y = -1;

for (let i = 0; i < bullets.length; i++) {
	let prePosition = bullets[i].bullet.position;
	let nextPosition = bullets[i].bullet.position
		.clone()
		.add(bullets[i].direction.clone().setLength(1));
	let C = preditor.pos.clone().center;
	let R = preditor.size;

	let dis = bullets[i].bullet.position
		.clone()
		.sub(preditor.pos)
		.length();
		
	let c = new THREE.Mesh();
	c.position.set(nearObstacle().mesh.position.x,0,nearObstacle().mesh.position.z);

	if (dis < 8) {
		x = i;
		y = 0;
	}
	
	if(dis < 15){
		let p = findP(c);
		findP(c);
		findP1(c);
		findHidePlace(c, p);
		preditor.fsm.beattacked();
		preditor.setSeekTarget(30 * Math.cos((pAngle + p1Angle) / 2) +nearObstacle().center.x,0,30 * Math.sin((pAngle + p1Angle) / 2) +nearObstacle().center.z);
	}


	bullets[i].bullet.position.copy(nextPosition);
    if(bullets[i].bullet.position.x > 200 || bullets[i].bullet.position.x < -200||
    bullets[i].bullet.position.z > 200 || bullets[i].bullet.position.z < -200){

        scene.remove(bullets[i].bullet);
        bullets.splice(i, 1);
    }
}

if (x !== -1 && y !== -1) {
	
	scene.remove(bullets[x].bullet);
	bullets.splice(x, 1);
	
	/////////////////////
	HpL -= ATTACKL;
	console.log(Hp);
	document.querySelector(".hp_Led").style.width = `${HpL}%`;
					
	if(HpL == 0){
		lifeNumL--;
		scene.remove(preditor.mesh);
	}
			
	if(lifeNumL == 3){
					
		document.getElementById("heartLed").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">  <img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">  <img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">';
	}
	else if(lifeNumL == 2){
					
		document.getElementById("heartLed").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">  <img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">';
	}
	else if(lifeNumL == 1){
					
		document.getElementById("heartLed").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">';
	}
	else{
		document.getElementById("heartLed").innerHTML = '';
					
	}
				
				
	}
}
function preyThrough() {

	let x = -1,y = -1;

	for (let i = 0; i < bullets.length; i++) {
		let prePosition = bullets[i].bullet.position;
		let nextPosition = bullets[i].bullet.position
			.clone()
			.add(bullets[i].direction.clone().setLength(1));
		let C = prey.pos.clone().center;
		let R = prey.size;

		let dis = bullets[i].bullet.position
			.clone()
			.sub(prey.pos)
			.length();
			
		let c = new THREE.Mesh();
		c.position.set(nearObstacle().mesh.position.x,0,nearObstacle().mesh.position.z);

		if (dis < 8) {
			x = i;
			y = 0;
            shooted = true;
		}
        else    
            shooted = false;

		bullets[i].bullet.position.copy(nextPosition);
        if(bullets[i].bullet.position.x > 200 || bullets[i].bullet.position.x < -200||
        bullets[i].bullet.position.z > 200 || bullets[i].bullet.position.z < -200){

            scene.remove(bullets[i].bullet);
            bullets.splice(i, 1);
        }
	}

	if (x !== -1 && y !== -1) {
		
		scene.remove(bullets[x].bullet);
		bullets.splice(x, 1);
		
		/////////////////////
		Hp -= ATTACK;
		document.querySelector(".hp_Cap").style.width = `${Hp}%`;
						
		if(Hp == 0){
			lifeNum--;
			scene.remove(prey.mesh);
		}
				
		if(lifeNum == 3){
						
			document.getElementById("heartCap").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">  <img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">  <img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">';
		}
		else if(lifeNum == 2){
						
			document.getElementById("heartCap").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">  <img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">';
		}
		else if(lifeNum == 1){
						
			document.getElementById("heartCap").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">';
		}
		else{
			document.getElementById("heartCap").innerHTML = '';
			
						
		}
					
	}
}
function defenseThrough() {

	let x = -1,y = -1;

	for (let i = 0; i < bullets.length; i++) {
		let prePosition = bullets[i].bullet.position;
		let nextPosition = bullets[i].bullet.position
			.clone()
			.add(bullets[i].direction.clone().setLength(1));
		let C = defense.pos.clone().center;
		let R = defense.size;

		let dis = bullets[i].bullet.position
			.clone()
			.sub(defense.pos)
			.length();
			
		let c = new THREE.Mesh();
		c.position.set(nearObstacle().mesh.position.x,0,nearObstacle().mesh.position.z);

		if (dis < 8) {
			x = i;
			y = 0;
		}
		


		bullets[i].bullet.position.copy(nextPosition);
        if(bullets[i].bullet.position.x > 200 || bullets[i].bullet.position.x < -200||
        bullets[i].bullet.position.z > 200 || bullets[i].bullet.position.z < -200){

            scene.remove(bullets[i].bullet);
            bullets.splice(i, 1);
        }
	}

	if (x !== -1 && y !== -1) {
		
		scene.remove(bullets[x].bullet);
		bullets.splice(x, 1);
		
		/////////////////////
		HpD -= ATTACKD;
		document.querySelector(".hp_Def").style.width = `${HpD}%`;
						
		if(HpD == 0){
			lifeNumD--;
			scene.remove(defense.mesh);
		}
				
		if(lifeNumD == 3){
						
			document.getElementById("heartDef").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">  <img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">  <img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">';
		}
		else if(lifeNumD == 2){
						
			document.getElementById("heartDef").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">  <img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">';
		}
		else if(lifeNumD == 1){
						
			document.getElementById("heartDef").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">';
		}
		else{
			document.getElementById("heartDef").innerHTML = '';
						
		}
					
					
		}
}
function defenseLThrough() {

	let x = -1,y = -1;

	for (let i = 0; i < bullets.length; i++) {
		let prePosition = bullets[i].bullet.position;
		let nextPosition = bullets[i].bullet.position
			.clone()
			.add(bullets[i].direction.clone().setLength(1));
		let C = defenseL.pos.clone().center;
		let R = defenseL.size;

		let dis = bullets[i].bullet.position
			.clone()
			.sub(defenseL.pos)
			.length();
			
		let c = new THREE.Mesh();
		c.position.set(nearObstacle().mesh.position.x,0,nearObstacle().mesh.position.z);

		if (dis < 8) {
			x = i;
			y = 0;
		}
		


		bullets[i].bullet.position.copy(nextPosition);
        if(bullets[i].bullet.position.x > 200 || bullets[i].bullet.position.x < -200||
        bullets[i].bullet.position.z > 200 || bullets[i].bullet.position.z < -200){

            scene.remove(bullets[i].bullet);
            bullets.splice(i, 1);
        }
	}

	if (x !== -1 && y !== -1) {
		
		scene.remove(bullets[x].bullet);
		bullets.splice(x, 1);
		
		/////////////////////
		HpDL -= ATTACKDL;
		document.querySelector(".hp_DefL").style.width = `${HpDL}%`;
						
		if(HpDL == 0){
			lifeNumDL--;
			scene.remove(defenseL.mesh);
		}
				
		if(lifeNumDL == 3){
						
			document.getElementById("heartDefL").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">  <img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">  <img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">';
		}
		else if(lifeNumDL == 2){
						
			document.getElementById("heartDefL").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">  <img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">';
		}
		else if(lifeNumDL == 1){
						
			document.getElementById("heartDefL").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">';
		}			
					
	}
}
function defenseRThrough() {

	let x = -1,y = -1;

	for (let i = 0; i < bullets.length; i++) {
		let prePosition = bullets[i].bullet.position;
		let nextPosition = bullets[i].bullet.position
			.clone()
			.add(bullets[i].direction.clone().setLength(1));
		let C = defenseR.pos.clone().center;
		let R = defenseR.size;

		let dis = bullets[i].bullet.position
			.clone()
			.sub(defenseR.pos)
			.length();
			
		let c = new THREE.Mesh();
		c.position.set(nearObstacle().mesh.position.x,0,nearObstacle().mesh.position.z);

		if (dis < 8) {
			x = i;
			y = 0;
		}
		


		bullets[i].bullet.position.copy(nextPosition);
        if(bullets[i].bullet.position.x > 200 || bullets[i].bullet.position.x < -200||
        bullets[i].bullet.position.z > 200 || bullets[i].bullet.position.z < -200){

            scene.remove(bullets[i].bullet);
            bullets.splice(i, 1);
        }
	}

	if (x !== -1 && y !== -1) {
		
		scene.remove(bullets[x].bullet);
		bullets.splice(x, 1);
		
		/////////////////////
		HpDR -= ATTACKDR;
		document.querySelector(".hp_DefR").style.width = `${HpDR}%`;
						
		if(HpDR == 0){
			lifeNumDR--;
			scene.remove(defenseR.mesh);
		}
				
		if(lifeNumDR == 3){
						
			document.getElementById("heartDefR").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">  <img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">  <img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">';
		}
		else if(lifeNumDR == 2){
						
			document.getElementById("heartDefR").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">  <img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">';
		}
		else if(lifeNumDR == 1){
						
			document.getElementById("heartDefR").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">';
		}	
		else{
			document.getElementById("heartDefR").innerHTML = "";
		}
					
	}
}

function preydown(){
	prey.setSeekTarget(-170,0, -170);
}
function preditordown(){
	preditor.setSeekTarget(-170,0, -170);
}
function defensedown(){
	defense.setSeekTarget(-170,0, -170);
	
}
function defenseRdown(){
	defenseR.setSeekTarget(-170,0, -170);

}
function defenseLdown(){
	defenseL.setSeekTarget(-170,0, -170);
	
}
function soldierdown(){
	soldier.setSeekTarget(170,0, 170);
	
}
  

function SoldierBeAttacked() {

     let x = -1,y = -1;

    for (let i = 0; i < bullets2.length; i++) {
        let prePosition = bullets2[i].bullet2.position;
        let nextPosition = bullets2[i].bullet2.position
        .clone()
        .add(bullets2[i].direction.clone().setLength(5));
        let C = soldier.pos.clone().center;
        let R = soldier.size;

        let dis = bullets2[i].bullet2.position
        .clone()
        .sub(soldier.pos)
        .length();


        if (dis < 8) {
            x = i;
            y = 0;
        }


        bullets2[i].bullet2.position.copy(nextPosition);
        if(bullets2[i].bullet2.position.x > 200 || bullets2[i].bullet2.position.x < -200||
        bullets2[i].bullet2.position.z > 200 || bullets2[i].bullet2.position.z < -200){

            scene.remove(bullets2[i].bullet2);
            bullets2.splice(i, 1);
        }
    }
     if (x !== -1 && y !== -1) {

      scene.remove(bullets2[x].bullet2);
      bullets2.splice(x, 1);

      /////////////////////
      HpS -= ATTACKS;
      document.querySelector(".hp_Sol").style.width = `${HpS}%`;

      if(HpS == 0){
       lifeNumS--;
       scene.remove(soldier.mesh);

      }

      if(lifeNumS == 3){

       document.getElementById("heartSol").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">  <img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">  <img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">';
      }
      else if(lifeNumS == 2){

       document.getElementById("heartSol").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">  <img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">';
      }
      else if(lifeNumS == 1){

       document.getElementById("heartSol").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">';
      }
      else{
       document.getElementById("heartSol").innerHTML = '';

      }


    }
}   

function cancel(){
	scene.remove(rebir);
}
function cancel2(){
	scene.remove(rebir2);
}

function solShow(){
	scene.add(soldier.mesh);
}

function SoldierMoving(dt) {
	
	var dis = soldier.pos.distanceTo(nearObstacleSold().mesh.position);
	
	//console.log(soldier.mesh.children[1].position);
	
	if(movevel.length() > 0){
		angle = 1.5*Math.PI + Math.atan2(movevel.x,movevel.z);
	}
	if (keyboard.pressed("up")) {
		power *= 1.2;
	}
	if (keyboard.pressed("down")) {
		power /= 1.2;
		
	}
	
	
	power = Math.clamp (power, 0, 50.0);
	
	var angle_thrust = angle;
	if (keyboard.pressed("left")) {
		 angle_thrust += 0.8;
	}
	if (keyboard.pressed("right")) {
		angle_thrust -= 0.8;
		
	}

	var thrust = new THREE.Vector3(1,0,0).multiplyScalar(power).applyAxisAngle (new THREE.Vector3(0,1,0), angle_thrust);
	moveforce.copy (thrust);
	moveforce.add(movevel.clone().multiplyScalar(-2))
	movevel.add(moveforce.clone().multiplyScalar(dt));
	/*if(movepos.x > 195 || movepos.x < -195||  movepos.z < -195 || movepos.z > 195){
		movepos.sub(movevel.clone().multiplyScalar(dt));
	}else{
		movepos.add(movevel.clone().multiplyScalar(dt));
	}*/
	if(movepos.x <= 195 || movepos.x >= -195||  movepos.z >= -195 || movepos.z <= 195){
		movepos.add(movevel.clone().multiplyScalar(dt));
	}
	if(movepos.x > 195 && movepos.z > 195 || movepos.x < -195 && movepos.z <-195 || movepos.x < -195 && movepos.z > 195 || movepos.x > 195 && movepos.z < -195)
		movepos.sub(movevel.clone().multiplyScalar(dt));
		

	for(var i = 0;i < scene.obstacles.length ; i++){
		
		if(dis < nearObstacleSold().size + 8){
			movepos.sub(movevel.clone().multiplyScalar(dt));
		}
		
	}
    if(soldier.pos.z > 195 || soldier.pos.z < -195 || soldier.pos.x > 195 ||soldier.pos.x < -195){
        movepos.sub(movevel.clone().multiplyScalar(dt));
    }
	
	let disPrey = soldier.pos.distanceTo(prey.pos);
	let disPred = soldier.pos.distanceTo(preditor.pos);
	let disDef = soldier.pos.distanceTo(defense.pos);
	let disDefL = soldier.pos.distanceTo(defenseL.pos);
	let disDefR = soldier.pos.distanceTo(defenseR.pos);
	
    if(disPrey <= 17 || disPred <= 17 || disDef <= 17 ||disDefL <= 17|| disDefR <= 17){
        movepos.sub(movevel.clone().multiplyScalar(dt));
    }else if(disPrey > 17 || disPred > 17 || disDef > 17 ||disDefL > 17|| disDefR > 17){
		movepos.add(movevel.clone().multiplyScalar(dt));
	}

    
	if(inHUD){
		let soldierPos = soldier.mesh.children[2].localToWorld(new THREE.Vector3()).clone();
		let cameraPos = camera.localToWorld(new THREE.Vector3()).clone();
		
		let dir = soldierPos.clone().sub(cameraPos);
		dir.y = 0;
		camera.lookAt(cameraPos.clone().add(dir));
	
	}
	if(keyboard.down("shift")){
		zoom = true;
		inHUD = true;
	
		//camera.position.copy(new THREE.Vector3(20,0,5));
		soldier.mesh.localToWorld(camera);
		//camera.lookAt(soldier.pos.clone().add(new THREE.Vector3(21,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), angle_thrust)).add(new THREE.Vector3(0,2,0)));
	}
	else if(keyboard.up("shift")){
		inHUD = false;
		zoom = false;

		soldier.mesh.children[2].remove(camera);
	}
		camera.updateProjectionMatrix();
}

function restartHpLifeBullet(){	//重設血量和生命值
	Hp = 100;
	HpS = 100;
	HpL = 100;
	HpD = 100;
	HpDL = 100;
	HpDR = 100;
	lifeNum = 3;
	lifeNumL = 3;
	lifeNumS = 3;
	lifeNumD = 3;
	lifeNumDR = 3;
	lifeNumDL = 3;

	//Hp
	document.querySelector(".hp_Cap").style.width = `${Hp}%`;
	document.querySelector(".hp_Led").style.width = `${HpL}%`;
	document.querySelector(".hp_Def").style.width = `${HpD}%`;
	document.querySelector(".hp_DefL").style.width = `${HpDL}%`;
	document.querySelector(".hp_DefR").style.width = `${HpDR}%`;
	document.querySelector(".hp_Sol").style.width = `${HpS}%`;
	//愛心
	document.getElementById("heartCap").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">  <img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">  <img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">';
	document.getElementById("heartLed").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">  <img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">  <img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">';
	document.getElementById("heartDef").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">  <img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">  <img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">';
	document.getElementById("heartDefL").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">  <img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">  <img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">';
	document.getElementById("heartDefR").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">  <img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">  <img src="https://i.imgur.com/gPrrPdn.png" width = "30" height = "30">';
	document.getElementById("heartSol").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">  <img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">  <img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">';
	//子彈
	document.getElementById("bullet").innerHTML = '<img src="https://i.imgur.com/2WfaiMG.png" width = "40" height = "50"> <img src="https://i.imgur.com/2WfaiMG.png" width = "40" height = "50"> <img src="https://i.imgur.com/2WfaiMG.png" width = "40" height = "50">';
	
}

function restartgame() {
	state = -1;
	end.innerHTML = "";
	restart.innerHTML = "";
	
	
	//start = document.getElementById("start");
	//start.innerHTML = "Press enter to begin";
	
	restartHpLifeBullet();

	insert = false;
	theta = 0;
	HH = 12;
	hide = false;
	stop = false;
	front = false;
	hidden = false;
	count = 0;
	get = false;
	attack = false;
	can = false;
	seeWarrior = false,seeCapturer = false;
	soldierFlag = false;
	second = 0;
	already = 1;

    moveStop = false;
    movepos = new THREE.Vector3(175,0,175);
    movevel = new THREE.Vector3();
    moveforce = new THREE.Vector3();
    power = 5.0;
    angle = 0.0;
    
	var x = Math.random() * 380 - 190;
	flag.position.set(x, 8, -x);

	let dt = clock.getDelta();
	prey.pos.set(-175, 0, -175);
	prey.update(dt, time);
	prey.fsm.restart();
	
	
}


function animate() {
    
	animate.distance = animate.distance ? animate.distance : 0;
	//requestAnimationFrame(animate);

	let dt = clock.getDelta();
	time = clock.getElapsedTime();
	
	keyboard.update();
	/*
	soldier.mesh.children[0].rotation.y = -Math.PI/2;
	let cameraPos = new THREE.Vector3(10,40,1);
	soldier.mesh.children[1].localToWorld (cameraPos);
	camera.position.copy (cameraPos);
	let cameraLookAt = new THREE.Vector3(10,30,1);
	soldier.mesh.children[1].localToWorld (cameraLookAt);
	camera.lookAt (cameraLookAt);*/

	preditor.update(dt);
	prey.update(dt, time);
	checkRaycaster();
	
	SoldierShooting();
	ShootThrough();
	preyThrough();
	defenseThrough();
	defenseLThrough();
	defenseRThrough();
	soldier.update(dt);
    SoldierBeAttacked();

	//findNbhd(agents);
	agents.forEach(function (agent) {
		defenseR.update(dt);
		defense.update(dt);
		defenseL.update(dt);
	});
	
	bullets2.forEach(function (data) {
		data.bullet2.position.add(
			data.direction.clone().setLength(1)
		);
	});

	
	//hiddenOrNot();
	prey.findTarget(flag);
	soldier.findTarget();
	var dst = prey.pos.distanceTo(flag.position);
	var disToSoldier = prey.pos.distanceTo(soldier.pos);

	

	var c = new THREE.Mesh();
	c.position.set(
		nearObstacle().mesh.position.x,
		0,
		nearObstacle().mesh.position.z
	);

	var endPlace = new THREE.Mesh();
	endPlace.position.set(175, 0, 175);
	var endPlaceSol = new THREE.Mesh();
	endPlaceSol.position.set(-175, 0, -175);
	
	
	if (
		Math.abs(soldier.pos.x - flag.position.x) < 5 &&
		Math.abs(soldier.pos.z - flag.position.z) < 5 &&
		get === false &&
		insert === false &&
		endCapturer === false
	) {
		flag.position.set(soldier.pos.x, 10, soldier.pos.z);
		soldierFlag = true;
	} else {
		soldierFlag = false;
	}

	if (soldierFlag === false) {
        var hiding;
        if(disToSoldier < 75 && seeWarrior === true && seeCapturer === true)
            hiding = true;
        else
            hiding = false;

		if (
			hiding ===  true ||
            shooted === true
		) {
			already -= 1;

			//get = false;
			attack = true;
			prey.fsm.attacked();
			var p = findP(c);
			findHidePlace(c, p);
		} else if (second > 8 || attack === false) {
			already = 1;

			attack = false;
			if (get === true || insert === true) {
				prey.fsm.takeFlag();
			} else if (dst < 75 /*&& front === true*/) {
				prey.fsm.seeFlag();
			} else {
				/*if (dst >= 200 && front === false && get === false) */
				prey.fsm.findFlag();
			}
		}
	}
	if (soldierFlag === true) {
		prey.fsm.defense();
		preditor.fsm.shoot();
	}
	
	if (	//去插旗
		Math.abs(prey.pos.x - endPlace.position.x) < 5 &&
		Math.abs(prey.pos.z - endPlace.position.z) < 5 &&
		insert === true &&
		get === true
	) {
		endCapturer = true;
		prey.setBrake(10);
	}

	
	animate.distance = dst;
	
	bullets.forEach(function(data){
		data.bullet.position.add(data.direction.clone().setLength(1));
	});
	rebir.rotation.z += 0.05;
	rebir2.rotation.z += 0.05;
	
	leaderSign.rotation.y += 0.05;
	enemySign.rotation.y += 0.05;
	//Flag
	let cameraRoot = camera.position.clone();
	cameraRoot.y = 0;
	flag.lookAt(cameraRoot);
	
	//tree看鏡頭
	trees.forEach (function(t) {t.lookAt (cameraRoot)});
	trees2.forEach (function(t) {t.lookAt (cameraRoot)});
	trees3.forEach (function(t) {t.lookAt (cameraRoot)});
	trees4.forEach (function(t) {t.lookAt (cameraRoot)});
//////////////soldierMove
    if(moveStop == false){
        SoldierMoving(dt);
        soldier.pos.copy(movepos);
        soldier.mesh.rotation.y = angle;
    }
	//玩家視角(帥)
	

	
	
	// 讓「車蓋」方位永遠固定
	//soldier.mesh.children[0].quaternion.copy(
		//soldier.mesh.quaternion.clone().invert()
	//);
	prey.mesh.children[0].quaternion.copy(
		prey.mesh.quaternion.clone().invert()
	);
	preditor.mesh.children[3].quaternion.copy(
		preditor.mesh.quaternion.clone().invert()
	);
	defense.mesh.children[2].quaternion.copy(
		defense.mesh.quaternion.clone().invert()
	);
	defenseR.mesh.children[2].quaternion.copy(
		defenseR.mesh.quaternion.clone().invert()
	);
	defenseL.mesh.children[2].quaternion.copy(
		defenseL.mesh.quaternion.clone().invert()
	);
	
	//士兵的視角範圍
	
	let preyToSoldier = soldier.pos.clone().sub(prey.pos);
	let preyToDir = prey.mesh.localToWorld(new THREE.Vector3(10,0,0))
		.sub(prey.mesh.localToWorld(new THREE.Vector3(0,0,0))).normalize();
	
	raycaster.set(prey.pos,preyToDir);
	let intersects = raycaster.intersectObjects(pickables,true);
	
	let distanceNow = soldier.pos.distanceTo(prey.pos);
	let targetAngle = preyToSoldier.dot(preyToDir);
	
	
	//如果prey進入'hide'，守衛也會進入defense
	if(prey.fsm.state === "hide"){
		stop = true;
	}
	else if(distanceNow < 80){	
		if(targetAngle > 0 ){	
		//如果prey解除hide，但戰士仍在視野範圍內，仍會defense
			stop = true; 
		}
		else{
			stop = false;
		}
	}
	else{
		stop = false;
	}
	

	if (defenseR.fsm.state === "follow" && stop === true) {
		defenseR.fsm.attack();
		defense.fsm.attack();
		defenseL.fsm.attack();
	}
	if (defenseR.fsm.state === "defense" && stop === false) {
		defenseR.fsm.noattack();
		defense.fsm.noattack();
		defenseL.fsm.noattack();
	}
	
	/*
	renderer.clear(true);
	renderer.render(scene, camera);
	if(zoom)
		renderer.render (hudScene, hudCamera); 
	
	*/
	if (state === -1) {
		prey.setBrake(10);
		//prey.fsm.restart();
		
		prey.pos.set(-200, 20, -170);
		prey.setSeekTarget(-170,20, -170);
		setTimeout(preydown,500);
	
		soldier.pos.set(200,20, 170);
		soldier.setSeekTarget(170,20, 170);
		setTimeout(soldierdown,500);
		
		preditor.pos.set(-200,20, -170);
		defense.pos.set(-200,20, -170);
		defenseL.pos.set(-200,20, -170);
		defenseR.pos.set(-200,20, -170);
		
		scene.add(prey.mesh,preditor.mesh,defense.mesh,defenseL.mesh,defenseR.mesh,soldier.mesh);
	}

	if (state === 0) {
		//start.innerHTML = "";
		prey.findTarget(flag);
		//scene.add(rebir,rebir2);
		setTimeout(cancel,3000);
        setTimeout(cancel2,3000);
	}
	
	if (document.getElementById("introduction").style.display == "none" && state === -1) {
		state = 0;
	}
	
	if (prey.fsm.state === "touchDown" && endCapturer == true) {
		end.innerHTML = "You lose.";
		restart.innerHTML = "Press enter to restart.";
		state = -2;
		//console.log(state);
	}
	//console.log(soldierFlag);
	if(soldierFlag == true && Math.abs(soldier.pos.x - endPlaceSol.position.x) < 8 &&
		Math.abs(soldier.pos.z - endPlaceSol.position.z) < 8){
		end.innerHTML = "Player wins.";
		restart.innerHTML = "Press enter to restart.";
		state = -2;
		console.log(state);
        soldier.setBrake(10);
        moveStop = true;
	}
	
	if (keyboard.down("enter") && state === -2) {
		scene.add(rebir,rebir2);
		restartgame();
	}
	
	/////血量//////
	if(Hp == 0){
		if(lifeNum != 0){
			Hp = 100;
			document.querySelector(".hp_Cap").style.width = `${Hp}%`;
			
			get = false;
            insert = false;
			prey.fsm.findFlag();
			scene.add(rebir);
			rebir.position.set(-175,20,-170);
			scene.add(prey.mesh);
			
			prey.pos = rebir.position.clone();
			setTimeout(cancel,3000);
			
		}
		else {	//lifeNum != 0
			state = -2;
			end.innerHTML = "Player wins.";
			restart.innerHTML = "Press enter to restart.";
			
			soldier.setBrake(10);
			defense.setBrake(10);
			defenseL.setBrake(10);
			defenseR.setBrake(10);
			preditor.setBrake(10);
		}
		
	}
	if(HpL == 0){
		if(lifeNumL != 0){
			HpL = 100;
			document.querySelector(".hp_Led").style.width = `${HpL}%`;		
			
			scene.add(rebir);
			rebir.position.set(-200,20,-170);
			scene.add(preditor.mesh);
						
			preditor.pos = rebir.position.clone();
			preditor.setSeekTarget(-180,20, -170);
			setTimeout(preditordown,500);
			setTimeout(cancel,3000);
		}
					
	}
	if(HpD == 0){
		if(lifeNumD != 0){
			HpD = 100;
			document.querySelector(".hp_Def").style.width = `${HpD}%`;		
			
			scene.add(rebir);
			rebir.position.set(-200,20,-170);
			scene.add(defense.mesh);
						
			defense.pos = rebir.position.clone();
			defense.setSeekTarget(-180,20, -170);
			setTimeout(defensedown,500);
			setTimeout(cancel,3000);
		}
					
	}
	if(HpDL == 0){
		if(lifeNumDL != 0){
			HpDL = 100;
			document.querySelector(".hp_DefL").style.width = `${HpDL}%`;		
			
			scene.add(rebir);
			rebir.position.set(-200,20,-170);
			scene.add(defenseL.mesh);
						
			defenseL.pos = rebir.position.clone();
			defenseL.setSeekTarget(-180,20, -170);
			setTimeout(defenseLdown,500);
			setTimeout(cancel,3000);
		}
					
	}
	if(HpDR == 0){
		if(lifeNumDR != 0){
			HpDR = 100;
			document.querySelector(".hp_DefR").style.width = `${HpDR}%`;		
			
			scene.add(rebir);
			rebir.position.set(-200,20,-170);
			scene.add(defenseR.mesh);
						
			defenseR.pos = rebir.position.clone();
			defenseR.setSeekTarget(-180,20, -170);
			setTimeout(defenseRdown,500);
			setTimeout(cancel,3000);
		}
					
	}
	if(HpS == 0){	//士兵重生
		if(lifeNumS != 0){
			HpS = 100;
			document.querySelector(".hp_Sol").style.width = `${HpS}%`;		
			
			scene.add(rebir2);
			rebir2.position.set(200,20,170);
			setTimeout(solShow,1500);
						
			soldier.pos = rebir2.position.clone();
			soldier.setSeekTarget(180,20, 170);
			setTimeout(soldierdown,500);
			setTimeout(cancel2,3000);
            
            
            moveStop = false;
            movepos = new THREE.Vector3(175,0,175);
            movevel = new THREE.Vector3();
            moveforce = new THREE.Vector3();
            power = 5.0;
            angle = 0.0;
		}
		else{
			state = -2;
			end.innerHTML = "You lose.";
			restart.innerHTML = "Press enter to restart.";
			
			
			prey.setBrake(10);
			defense.setBrake(10);
			defenseL.setBrake(10);
			defenseR.setBrake(10);
			preditor.setBrake(10);
		}
					
	}
	//render();
	requestAnimationFrame( animate ); 
	renderer.render (scene, camera);
	
	
}

function render() {
	
		var WW = window.innerWidth;
		var HH = window.innerHeight;
		
		if(zoom)
			renderer.render (hudScene, hudCamera); 
		
		//小地圖透明
		// render scene to texture (topview)
		renderer.setRenderTarget (renderTarget);
		renderer.setClearColor(0xffffff);
		renderer.clear();
		
		renderer.render(scene, cameraTop);
		// ready to render to screen  
		renderer.setRenderTarget(null);  
		renderer.setClearColor(0x888888);
		renderer.clear();
		
		// render scene
		renderer.setViewport (0,0,WW, HH);
		renderer.render(scene, camera);
		
		// render minimap  
		// must render AFTER scene
		// (depthTest = false)
		//let mapSize = ww/3;
		renderer.setViewport(WW / 25, HH/2  , WW / 4, HH / 2);
		renderer.render (sceneRTT, cameraMap);
		
}

</script>
	</body>
</html>