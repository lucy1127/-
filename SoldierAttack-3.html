<!DOCTYPE html>
<html>
	<head>
		<style>
			#heading {
				text-align: center;
				position: absolute;
				width: 100vw;
			}
		</style>
	</head>
	<body style="overflow: hidden">
		<div id="heading">
			<h3 style="color: red">Soldier Attack<br /></h3>
		</div>

		<script src="state-machine.js"></script>
		<script src="https://threejs.org/build/three.min.js"></script>
		<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
		<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>

		<script type="module">
			javascript: (function () {
				var script = document.createElement("script");
				script.onload = function () {
					var stats = new Stats();
					document.body.appendChild(stats.dom);
					requestAnimationFrame(function loop() {
						stats.update();
						requestAnimationFrame(loop);
					});
				};
				script.src =
					"https://mrdoob.github.io/stats.js/build/stats.min.js";
				document.head.appendChild(script);
			})();

			import * as THREE from "https://threejs.org/build/three.module.js";
			import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";

			(function () {
				Math.clamp = function (val, min, max) {
					return Math.min(Math.max(val, min), max);
				};
			})();

			function sleep(milliseconds) {
				const start = Date.now();
				while (Date.now() - start < milliseconds);
			}

			class Obstacle {
				constructor(center, size) {
					this.center = center.clone();
					this.mesh = new THREE.Mesh(
						new THREE.CylinderGeometry(size, size, 20, 20),
						new THREE.MeshNormalMaterial()
					);
					this.mesh.position.copy(center);
					this.size = size;
					scene.add(this.mesh);
				}
			}

			class Avatar {
				constructor(pos, mesh) {
					this.pos = pos.clone();
					this.vel = new THREE.Vector3();
					this.force = new THREE.Vector3();
					this.MAXSPEED = 50;
					this.ARRIVAL_R = 30;

					this.size = 15;
					this.angle = 0; // for orientable agent
					this.mesh = mesh;
					scene.add(mesh);

					this.target = null;
					this.steermode = "";
					this.BRAKING = 0; // no brake
				}

				update(dt) {
					//console.log ('in avatar update ...');

					this.accumulateForce();
					this.vel.add(this.force.clone().multiplyScalar(dt));

					// ARRIVAL: velocity modulation
					if (this.target !== null) {
						let diff = this.target.clone().sub(this.pos);
						let dst = diff.length();
						if (dst < this.ARRIVAL_R) {
							this.vel.setLength(dst);
						}
					}

					// MAXSPEED modulation
					let speed = this.vel.length();
					this.vel.setLength(Math.clamp(speed, 0, this.MAXSPEED));
					this.pos.add(this.vel.clone().multiplyScalar(dt));
					this.mesh.position.copy(this.pos);

					// for orientable agent
					if (this.vel.length() > 1.0) {
						this.angle = Math.atan2(-this.vel.z, this.vel.x);
						this.mesh.rotation.y = this.angle;
					}
					// collision
					// for all obstacles in the scene
					let obs = scene.obstacles;

					// pick the most threatening one
					let theOne = null;
					let dist = 1e10;
					let vhat = this.vel.clone().normalize();
					const REACH = 50;
					const K = 5;
					let perp;
					for (let i = 0; i < obs.length; i++) {
						let point = obs[i].center.clone().sub(this.pos); // c-p
						let proj = point.dot(vhat);
						if (proj > 0 && proj < REACH) {
							perp = new THREE.Vector3();
							perp.subVectors(
								point,
								vhat.clone().setLength(proj)
							);
							let overlap =
								obs[i].size + this.size - perp.length();
							if (overlap > 0 && proj < dist) {
								theOne = obs[i];
								dist = proj;
								perp.setLength(K * overlap);
								perp.negate();
							}
						}
					}
					if (theOne) this.force.add(perp);

					this.vel.add(this.force.clone().multiplyScalar(dt));
				}

				setSeekTarget(x, y, z) {
					this.BRAKING = 0; // release Brake while seek
					this.steerMode = "SEEK";
					this._setTarget(x, y, z);
				}

				// target, Patrol & Hide
				setPatrolTarget(x, y, z) {
					this.BRAKING = 0;
					this.steerMode = "patrol";
					this._setTarget(x, y, z);
				}

				setAttackTarget(x, y, z) {
					this.BRAKING = 0;
					this.steerMode = "attack";
					//this._setTarget (x,y,z);
				}

				setHideTarget(x, y, z) {
					this.BRAKING = 0;
					this.steerMode = "hide";
					this._setTarget(x, y, z);
				}

				_setTarget(x, y, z) {
					// do not use directly
					if (this.target !== null) this.target.set(x, y, z);
					else {
						this.target = new THREE.Vector3(x, y, z);
					}
				}

				targetInducedForce(targetPos) {
					let sign = 0;
					if (
						this.steerMode === "patrol" ||
						this.steerMode === "SEEK"
					)
						sign = 1;
					else if (this.steerMode === "hide") sign = -1;

					return targetPos
						.clone()
						.sub(this.pos)
						.normalize()
						.multiplyScalar(sign * this.MAXSPEED)
						.sub(this.vel);
				}

				setBrake(brake) {
					// make the avatar stop gracefully
					this.BRAKING = brake;
					this.target = null; // release target
				}

				accumulateForce() {
					if (this.target)
						this.force.copy(this.targetInducedForce(this.target));
					else this.force.set(0, 0, 0); // for null-target initial force

					// braking ...
					this.force.add(
						this.vel.clone().multiplyScalar(-this.BRAKING)
					);
				}
			}
			class Agent extends Avatar {
				constructor(pos, mesh, name = "", fsm) {
					super(pos, mesh);
					this.fsm = fsm;
					this.stateSign = null;
				}
				update(dt) {
					super.update(dt); // calling avatar update

					// agent related ...
					// how to make the brain not so hyper-active
					if (this.fsm) {
						$("#preditorState").text(this.fsm.state);

						if (this.fsm.state === "hide")
							super.setHideTarget(
								target.position.x,
								0,
								target.position.z
							);

						if (this.fsm.state === "patrol") {
							super.setBrake(10);
							this.mesh.children[0].material.visible = true;
							this.mesh.children[1].material.visible = false;
						}
						if (this.fsm.state === "attack") {
							this.mesh.children[0].material.visible = false;
							this.mesh.children[1].material.visible = true;
						}
					}
					if (this.stateSign) {
						this.stateSign.position.copy(this.pos);
						this.stateSign.position.y = 10;
						this.stateSign.lookAt(
							camera.position.x,
							50,
							camera.position.z
						);

						if (this.fsm.state === "patrol") {
							this.stateSign.children[0].material.visible = true;
							this.stateSign.children[1].material.visible = false;
							this.stateSign.children[2].material.visible = false;
						}
						if (this.fsm.state === "hide") {
							this.stateSign.children[1].material.visible = true;
							this.stateSign.children[0].material.visible = false;
							this.stateSign.children[2].material.visible = false;
						}
						if (this.fsm.state === "attack") {
							this.stateSign.children[0].material.visible = false;
							this.stateSign.children[1].material.visible = false;
							this.stateSign.children[2].material.visible = true;
						}
					}
				}
			}
			class CapturerAgent extends Avatar {
				constructor(pos, mesh, name = "", fsm) {
					super(pos, mesh);
					this.fsm = fsm;
					// initial state got from fsm.state;
					this.stateSign = null;
				}

				update(dt, time) {
					if (this.pos.z > 120) {
						this.pos.z = 120;
					} else if (this.pos.z < -120) {
						this.pos.z = -120;
					}
					if (this.pos.x > 120) {
						this.pos.x = 120;
					} else if (this.pos.x < -120) {
						this.pos.x = -120;
					}
					super.update(dt); // calling avatar update
					if (this.fsm) {
						$("#preyState").text(this.fsm.state);

						if (this.fsm.state === "snatch") {
							super.setSeekTarget(
								flag.position.x,
								0,
								flag.position.z
							);

							if (
								Math.abs(flag.position.x - this.pos.x) < 5 &&
								Math.abs(flag.position.z - this.pos.z) < 5
							) {
								get = true;
								insert = true;
							}
						}
						if (this.fsm.state === "search") {
							var angle = Math.PI / 8;

							if (time < 0.5) {
								if (count > 0.5) {
									var vLeft = this.mesh.localToWorld(
										new THREE.Vector3(
											30 * Math.cos(angle),
											0,
											-30 * Math.sin(angle)
										)
									);
									super.setSeekTarget(vLeft.x, 0, vLeft.z);
								}
								if (count < 0.5) {
									var vRight = this.mesh.localToWorld(
										new THREE.Vector3(
											30 * Math.cos(angle),
											0,
											30 * Math.sin(angle)
										)
									);
									super.setSeekTarget(vRight.x, 0, vRight.z);
								}
							} else {
								var v2 = this.mesh.localToWorld(
									new THREE.Vector3(30, 0, 0)
								);
								super.setSeekTarget(v2.x, 0, v2.z);
							}
						}
						//super.setBrake(10);

						if (this.fsm.state === "hide") {
							insert = false;

							super.setSeekTarget(
								35 * Math.cos((pAngle + p1Angle) / 2) +
									nearObstacle().center.x,
								0,
								35 * Math.sin((pAngle + p1Angle) / 2) +
									nearObstacle().center.z
							);
						}
						if (this.fsm.state === "touchDown") {
							if (get === true) {
								flag.position.set(this.pos.x, 10, this.pos.z);
							}
							if (insert === true) {
								super.setSeekTarget(120, 0, 0);
							}
						}
						if (this.fsm.state === "endGame") {
							super.setSeekTarget(-90, 0, -90);
						}
					}
					if (this.stateSign) {
						this.stateSign.position.copy(this.pos);
						this.stateSign.position.y = 30;
						this.stateSign.lookAt(
							camera.position.x,
							10,
							camera.position.z
						);

						if (this.fsm.state === "snatch") {
							this.stateSign.children[0].material.visible = true;
							this.stateSign.children[1].material.visible = false;
							this.stateSign.children[2].material.visible = false;
							this.stateSign.children[3].material.visible = false;
							this.mesh.children[2].material.visible = true;
							this.mesh.children[3].material.visible = false;
							this.mesh.children[4].material.visible = false;
							this.mesh.children[5].material.visible = false;
						}
						if (this.fsm.state === "search") {
							this.stateSign.children[1].material.visible = true;
							this.stateSign.children[0].material.visible = false;
							this.stateSign.children[2].material.visible = false;
							this.stateSign.children[3].material.visible = false;
							this.mesh.children[2].material.visible = true;
							this.mesh.children[3].material.visible = false;
							this.mesh.children[4].material.visible = false;
							this.mesh.children[5].material.visible = false;
						}
						if (this.fsm.state === "hide") {
							this.stateSign.children[2].material.visible = true;
							this.stateSign.children[0].material.visible = false;
							this.stateSign.children[1].material.visible = false;
							this.stateSign.children[3].material.visible = false;
							this.mesh.children[3].material.visible = true;
							this.mesh.children[4].material.visible = false;
							this.mesh.children[2].material.visible = false;
							this.mesh.children[5].material.visible = false;
						}
						if (this.fsm.state === "touchDown") {
							this.stateSign.children[3].material.visible = true;
							this.stateSign.children[0].material.visible = false;
							this.stateSign.children[1].material.visible = false;
							this.stateSign.children[2].material.visible = false;
							this.mesh.children[4].material.visible = true;
							this.mesh.children[3].material.visible = false;
							this.mesh.children[2].material.visible = false;
							this.mesh.children[5].material.visible = false;
						}
						if (this.fsm.state === "endGame") {
							/*this.stateSign.children[3].material.visible = true;
						this.stateSign.children[0].material.visible = false;
						this.stateSign.children[1].material.visible = false;
						this.stateSign.children[2].material.visible = false;*/
							this.mesh.children[5].material.visible = true;
							this.mesh.children[3].material.visible = false;
							this.mesh.children[2].material.visible = false;
							this.mesh.children[4].material.visible = false;
						}
					}
				}
				/*straight() {
				start = true;
				setTimeout(this.straight(), 5000);
			}*/

				findTarget(target) {
					var point = target.position.clone().sub(this.pos);

					var preyDirect = this.mesh
						.localToWorld(new THREE.Vector3(1, 0, 0))
						.sub(this.mesh.localToWorld(new THREE.Vector3(0, 0, 0)))
						.normalize();
					ray.set(this.pos, preyDirect);
					//debugger;
					var intersects = ray.intersectObjects(pickables2, true);
					if (intersects.length > 0) {
						if (intersects[0].object.name != target.name) {
							//console.log(intersects[0].object.name);
							if (
								intersects[0].object.name ===
								soldier.mesh.children[2].name
							) {
								seeWarrior = true;
							} else seeWarrior = false;
							hidden = true;
						} else hidden = false;
					}

					var CosineValue = point.dot(preyDirect);
					if (CosineValue > 0 /*&& hidden === false*/) {
						front = true;
					} else {
						front = false;
					}
				}
			}

			function initFSM() {
				let fsm = new StateMachine({
					init: "search",
					transitions: [
						{ name: "seeFlag", from: "search", to: "snatch" },
						{ name: "seeFlag", from: "snatch", to: "snatch" },
						//{ name: "findFlag", from: "snatch", to: "search" },
						{ name: "findFlag", from: "hide", to: "search" },
						{ name: "findFlag", from: "search", to: "search" },
						{ name: "findFlag", from: "endGame", to: "search" },
						{ name: "attacked", from: "snatch", to: "hide" },
						{ name: "attacked", from: "search", to: "hide" },
						{ name: "attacked", from: "touchDown", to: "hide" },
						{ name: "attacked", from: "hide", to: "hide" },
						{ name: "takeFlag", from: "snatch", to: "touchDown" },
						{
							name: "takeFlag",
							from: "touchDown",
							to: "touchDown",
						},
						{ name: "defense", from: "endGame", to: "endGame" },
						{ name: "defense", from: "snatch", to: "endGame" },
						{ name: "defense", from: "search", to: "endGame" },
						{ name: "defense", from: "hide", to: "endGame" },
					],
				});
				return fsm;
			}

			var camera, scene, renderer, clock;
			var keyboard = new KeyboardState();
			var raycaster = new THREE.Raycaster();
			var soldier,
				preditor,
				prey,
				pickables = [],
				targets = [];
			var bullets = [],
				attack,
				attack2;
			var fire = false;
			var hudCamera,
				hudScene,
				zoom = false;
			var theta = 0,
				HH = 12;

			var ray, ray2;
			var mouse = new THREE.Vector2();
			var pickables = [],
				pickables2 = [];
			var front = false,
				hidden = false;
			var count = 0;
			var flag, prey, soldier;
			var get = false,
				insert = false;
			var times = 3;
			var soldierFlag = false;
			//var circleL, circleR, circleA;
			var seeWarrior = false;
			var attack = false;
			var pAngle, p1Angle;
			var end = false;
			var second = 0;
			var already = 1;

			init();
			initFSM();
			animate();

			function init() {
				clock = new THREE.Clock();
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(
					50,
					window.innerWidth / window.innerHeight,
					1,
					1000
				);
				camera.position.z = 120;
				camera.position.y = 100;

				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(0x888888);
				let controls = new OrbitControls(camera, renderer.domElement);
				document.body.appendChild(renderer.domElement);
				window.addEventListener("resize", onWindowResize, false);
				var gridXZ = new THREE.GridHelper(240, 24, "red", "white");
				scene.add(gridXZ);

				raycaster = new THREE.Raycaster();
				ray = new THREE.Raycaster();
				ray2 = new THREE.Raycaster();
				var plane = new THREE.Mesh(
					new THREE.PlaneGeometry(240, 240),
					new THREE.MeshBasicMaterial({
						transparent: true,
						opacity: 0.5,
						visible: true,
					})
				);
				scene.add(plane);
				plane.material.visible = false;
				plane.rotation.x = -Math.PI / 2;
				pickables = [plane];
				///////////////////////////////////////////////////////////////////////////////////////////////
				soldier = new Agent(
					new THREE.Vector3(90, 0, 0),
					soldierMesh(),
					"soldier"
				);
				//preditor = new Agent(new THREE.Vector3(),preditorMesh(),"T-Rex");
				prey = new CapturerAgent(
					randomPosZX(-100, 100),
					capturerMesh(),
					"sheep",
					initFSM()
				);
				let loader = new THREE.TextureLoader();
				loader.crossOrigin = "";
				let tex = loader.load("https://i.imgur.com/3YSMhL0.png");
				flag = new THREE.Mesh(
					new THREE.CircleGeometry(10, 20),
					new THREE.MeshBasicMaterial({
						map: tex,
						transparent: true,
						side: THREE.DoubleSide,
					})
				);
				var x = Math.random() * 200 - 100;
				flag.position.set(x, 8, -x);
				scene.add(flag);
				flag.name = "flag";

				///////////////////////////////////////////////////////////////////////////
				scene.obstacles = [];
				scene.obstacles.push(
					new Obstacle(new THREE.Vector3(40, 0, -30), 15)
				);
				scene.obstacles.push(
					new Obstacle(new THREE.Vector3(-90, 0, 0), 15)
				);
				scene.obstacles.push(
					new Obstacle(new THREE.Vector3(0, 0, -60), 15)
				);

				scene.obstacles[0].mesh.name = "obstacles";
				scene.obstacles[1].mesh.name = "obstacles";
				scene.obstacles[2].mesh.name = "obstacles";
				//pickables.push(prey.mesh);
				pickables2.push(
					flag,
					scene.obstacles[0].mesh,
					scene.obstacles[1].mesh,
					scene.obstacles[2].mesh,
					soldier.mesh.children[3]
				);
				///////////////////////////////////////////////////////////////////////////////////
				hudScene = new THREE.Scene();
				hudScene.add(
					new THREE.Mesh(
						new THREE.RingGeometry(12, 15, 30),
						new THREE.MeshBasicMaterial({ color: "black" })
					)
				);
				hudScene.add(
					new THREE.Mesh(
						new THREE.PlaneGeometry(40, 40),
						new THREE.MeshBasicMaterial({
							color: "yellow",
							transparent: true,
							opacity: 0.3,
						})
					)
				);
				hudScene.add(makeCross());

				hudCamera = new THREE.OrthographicCamera(
					-20,
					20,
					20,
					-20,
					-10,
					10
				);
				////////////////////////////////////
			}
			setInterval(function () {
				clock.elapsedTime = 0;
				count = Math.random();
			}, Math.random() * 1000 + 5000);

			function onDocumentMouseDown(event) {
				event.preventDefault();
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
				raycaster.setFromCamera(mouse, camera);
				var intersects = raycaster.intersectObjects(pickables);
				if (intersects.length > 0) {
					flag.position.copy(intersects[0].point);
					flag.position.y = 8;
				}
			}

			setInterval(function () {
				console.log(second);
				if (already > -1) second = 0;
				else second += 1;
			}, 1000);
			function randomPosZX(min, max) {
				let x = min + (max - min) * Math.random();
				let z = min + (max - min) * Math.random();

				return new THREE.Vector3(x, 0, z); //x,0,z);
			}
			function makeCross() {
				let cross = new THREE.Group();

				let geometry0 = new THREE.BufferGeometry();
				geometry0.setAttribute(
					new THREE.Vector3(-12, 0, 0),
					new THREE.Vector3(12, 0, 0)
				);
				let line0 = new THREE.Line(
					geometry0,
					new THREE.LineBasicMaterial({ color: "black" })
				);

				let geometry1 = new THREE.BufferGeometry();
				geometry1.setAttribute(
					new THREE.Vector3(0, -12, 0),
					new THREE.Vector3(0, 12, 0)
				);
				let line1 = new THREE.Line(
					geometry1,
					new THREE.LineBasicMaterial({ color: "black" })
				);

				cross.add(line0, line1);
				return cross;
			}
			function soldierMesh() {
				let loader = new THREE.TextureLoader();
				let icon = loader.load("https://i.imgur.com/C8sduKF.png");
				let loaderBody = new THREE.TextureLoader();
				let iconBody = loader.load("https://i.imgur.com/7yl0PLz.png");
				iconBody.wrapS = THREE.RepeatWrapping;
				iconBody.wrapT = THREE.RepeatWrapping;
				iconBody.repeat.set(5, 1);
				var body = new THREE.Mesh(
					new THREE.CylinderGeometry(8, 8, 4, 32, 1, true),
					new THREE.MeshBasicMaterial({
						map: iconBody,
						side: THREE.DoubleSide,
					})
				);
				var soldier = new THREE.Group();
				var mat = loader.load("https://i.imgur.com/7vbarnJ.jpeg");
				var pointerHeadTexture = loader.load(
					"https://i.imgur.com/93FViDI.png"
				);

				var pointer = new THREE.Mesh(
					new THREE.CylinderGeometry(1.5, 1.5, 15, 32),
					new THREE.MeshBasicMaterial({
						map: mat,
						side: THREE.DoubleSide,
					})
				);
				var pointerHead = new THREE.Mesh(
					new THREE.CylinderGeometry(1.7, 1.7, 2, 32, 1, true),
					new THREE.MeshBasicMaterial({
						map: pointerHeadTexture,
						side: THREE.DoubleSide,
					})
				);
				body.position.y = 2;
				pointer.rotation.z = Math.PI / 2;
				pointerHead.rotation.z = Math.PI / 2;
				pointerHead.position.set(15, 2, 0);
				pointer.position.set(7, 2, 0);

				// '帥'蓋
				let iconZX = new THREE.Group();
				let circle = new THREE.Mesh(
					new THREE.CircleGeometry(8, 128),
					new THREE.MeshBasicMaterial({ map: icon })
				);
				circle.position.y = 4;
				circle.rotation.x = -Math.PI / 2;
				iconZX.add(circle);

				attack = new THREE.Object3D();
				attack.position.set(5, 2, 0);
				attack2 = new THREE.Object3D();
				attack2.position.set(4, 2, 0);

				soldier.add(
					iconZX,
					pointer,
					pointerHead,
					body,
					attack,
					attack2
				);
				return soldier;
			}
			function capturerMesh() {
				let loader = new THREE.TextureLoader();
				let icon = loader.load("https://i.imgur.com/MIvqfLQ.png");
				let loaderBody = new THREE.TextureLoader();
				let iconBody = loader.load("https://i.imgur.com/MIvqfLQ.png");
				iconBody.wrapS = THREE.RepeatWrapping;
				iconBody.wrapT = THREE.RepeatWrapping;
				iconBody.repeat.set(5, 1);

				var capturer = new THREE.Group();
				var mat = new THREE.MeshNormalMaterial();
				var body = new THREE.Mesh(
					new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
					new THREE.MeshBasicMaterial({
						color: "lightGreen",
						map: iconBody,
						side: THREE.DoubleSide,
					})
				);
				var body2 = new THREE.Mesh(
					new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
					new THREE.MeshBasicMaterial({
						color: "yellow",
						map: iconBody,
						side: THREE.DoubleSide,
					}) //beAttacked
				);
				var body3 = new THREE.Mesh(
					new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
					new THREE.MeshBasicMaterial({
						color: "lightBlue",
						map: iconBody,
						side: THREE.DoubleSide,
					}) //touchDown
				);
				var body4 = new THREE.Mesh(
					new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
					new THREE.MeshBasicMaterial({
						color: "red",
						map: iconBody,
						side: THREE.DoubleSide,
					}) //endDown
				);
				var pointer = new THREE.Mesh(
					new THREE.BoxGeometry(15, 2, 2),
					mat
				);

				body.position.y = 2;
				pointer.position.set(5, 2, 0);

				// '車'蓋
				let iconZX = new THREE.Group();
				let circle = new THREE.Mesh(
					new THREE.CircleGeometry(8, 8),
					new THREE.MeshBasicMaterial({
						map: icon,
						side: THREE.DoubleSide,
					})
				);
				circle.position.y = 4;
				circle.rotation.x = -Math.PI / 2;
				iconZX.add(circle);

				capturer.add(iconZX, pointer, body, body2, body3, body4);
				return capturer;
			}
			function preditorMesh() {
				let loader = new THREE.TextureLoader();
				let icon = loader.load("https://i.imgur.com/9N9ohZ9.jpeg");
				let loaderBody = new THREE.TextureLoader();
				let iconBody = loader.load("https://i.imgur.com/9N9ohZ9.jpeg");
				iconBody.wrapS = THREE.RepeatWrapping;
				iconBody.wrapT = THREE.RepeatWrapping;
				iconBody.repeat.set(5, 1);

				var mat = loader.load("https://i.imgur.com/7vbarnJ.jpeg");
				var captain = new THREE.Group();
				var body = new THREE.Mesh(
					new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
					new THREE.MeshBasicMaterial({
						color: "green",
						map: iconBody,
						side: THREE.DoubleSide,
					})
				);
				var pointer = new THREE.Mesh(
					new THREE.CylinderGeometry(1.5, 1.5, 15, 32),
					new THREE.MeshBasicMaterial({
						map: mat,
						side: THREE.DoubleSide,
					})
				);
				body.position.y = 3;
				pointer.rotation.z = Math.PI / 2;
				pointer.position.set(4, 2, 0);

				// '帥'蓋
				let iconZX = new THREE.Group();
				let circle = new THREE.Mesh(
					new THREE.CircleGeometry(8, 32),
					new THREE.MeshBasicMaterial({ map: icon })
				);
				circle.position.y = 5;
				circle.rotation.x = -Math.PI / 2;
				iconZX.add(circle);

				captain.add(body, iconZX, pointer);
				return captain;
			}
			function SoldierMoving() {
				keyboard.update();

				if (keyboard.pressed("left"))
					soldier.setSeekTarget(soldier.pos.x - 40, 0, soldier.pos.z);
				if (keyboard.pressed("right"))
					soldier.setSeekTarget(soldier.pos.x + 40, 0, soldier.pos.z);
				if (keyboard.pressed("up"))
					soldier.setSeekTarget(soldier.pos.x, 0, soldier.pos.z - 40);
				if (keyboard.pressed("down"))
					soldier.setSeekTarget(soldier.pos.x, 0, soldier.pos.z + 40);
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}
			function SoldierShooting() {
				if (keyboard.pressed("space")) {
					fire = true;

					const geometry = new THREE.SphereGeometry(0.5, 32, 32);
					const material = new THREE.MeshBasicMaterial({
						color: "yellow",
					});
					let bullet = new THREE.Mesh(geometry, material);
					attack.getWorldPosition(bullet.position);

					let point = new THREE.Vector3();
					attack2.getWorldPosition(point);

					scene.add(bullet);

					let direction = bullet.position
						.clone()
						.sub(point)
						.normalize(); //創造方向

					bullets.push({
						bullet: bullet,
						direction: direction,
					});
				}
			}
			function checkAim() {
				if (keyboard.down("shift")) {
					zoom = true;
					camera.position.set(4, 3, 0);
					camera.fov = 25;
					camera.lookAt(
						attack
							.getWorldPosition(new THREE.Vector3())
							.clone()
							.add(new THREE.Vector3(0, 2, 0))
					);
				} else if (keyboard.up("shift")) {
					zoom = false;
					camera.position.set(3, 3, -15);
					camera.fov = 40;
					camera.lookAt(attack.getWorldPosition(new THREE.Vector3()));
				}

				camera.updateProjectionMatrix();
			}
			function ShootThrough() {
				let x = -1,
					y = -1;
				for (let i = 0; i < bullets.length; i++) {
					let prePosition = bullets[i].bullet.position;
					let nextPosition = bullets[i].bullet.position
						.clone()
						.add(bullets[i].direction.clone().setLength(10));
					let C = prey.pos.clone().center;
					let R = prey.size;

					let dis = bullets[i].bullet.position
						.clone()
						.sub(prey.pos)
						.length();

					if (dis < 8) {
						x = i;
						y = 0;
					}

					/*for(let j = 0; j < pickables.length; j++){
					//debugger;
					 let bulletPreLocalPosition = pickables[j].worldToLocal(prePosition.clone()).clone();
			           let bulletNextLocalPosition = pickables[j].worldToLocal(nextPosition.clone()).clone();

					let ac = new THREE.Vector3();
					ac.subVectors(C,bulletPreLocalPosition);
					//console.log(ac);
					let ab = new THREE.Vector3();
					ab.subVectors(C,bulletNextLocalPosition);
					//console.log(ab);
					var length2;
					let length = ac.clone().sub(ac.clone().projectOnVector(ab));
					length2 = length.length();
					console.log(length2);

					let dis = bullets[i].bullet.position.clone().sub(preditor.pos).length();

					if(dis < 8){
			               x = i;
			               y = j;
			           }
			       }*/
					bullets[i].bullet.position.copy(nextPosition);
				}

				if (x !== -1 && y !== -1) {
					console.log(x, y);
					scene.remove(bullets[x].bullet, prey.mesh);

					bullets.splice(x, 1);
					// pickables.splice(y,1);
				}
			}
			function nearObstacle() {
				var distances = [];
				var distance = prey.pos.distanceTo(
					scene.obstacles[0].mesh.position
				);
				distances.push(distance);
				var distance1 = prey.pos.distanceTo(
					scene.obstacles[1].mesh.position
				);
				distances.push(distance1);
				var distance2 = prey.pos.distanceTo(
					scene.obstacles[2].mesh.position
				);
				distances.push(distance2);

				var min = findMin(distance, distance1);
				min = findMin(min, distance2);

				if (min === distance) return scene.obstacles[0];
				if (min === distance1) return scene.obstacles[1];
				if (min === distance2) return scene.obstacles[2];
			}
			function findP(c) {
				var axis = new THREE.Vector3(0, 1, 0);
				var cp = new THREE.Vector3();
				var csDis = c.position.distanceTo(soldier.pos);
				var theta;
				var r = nearObstacle().size;
				theta = Math.acos(r / csDis);
				var cs = new THREE.Vector3();
				cs.subVectors(c.position, soldier.pos);
				cp = cs.setLength(r);
				cp.applyAxisAngle(axis, theta);
				var p = new THREE.Vector3();
				p.subVectors(c.position, cp);

				/*circleL.rotation.x = -Math.PI / 2;
			circleL.position.set(p.x, 0, p.z);*/
				return p;
			}
			function findP1(c) {
				var axis = new THREE.Vector3(0, 1, 0);
				var cp1 = new THREE.Vector3();
				var csDis = c.position.distanceTo(soldier.pos);
				var theta;
				var r = nearObstacle().size;
				theta = Math.acos(r / csDis);
				var cs = new THREE.Vector3();
				cs.subVectors(c.position, soldier.pos);
				cp1 = cs.setLength(r);
				cp1.applyAxisAngle(axis, -theta);
				var p1 = new THREE.Vector3();
				p1.subVectors(c.position, cp1);

				/*circleR.rotation.x = -Math.PI / 2;
			circleR.position.set(p1.x, 0, p1.z);*/
				return p1;
			}
			function findHidePlace(c, p) {
				var alpha, theta;
				var csDis = c.position.distanceTo(soldier.pos);
				var r = nearObstacle().size;
				theta = Math.acos(r / csDis);
				var psDis = p.distanceTo(soldier.pos);

				var cs = new THREE.Vector3();
				cs.subVectors(c.position, soldier.pos);

				alpha = Math.atan2(cs.z, cs.x);
				pAngle = alpha + theta;
				p1Angle = alpha - theta;
				if (pAngle < 0) {
					pAngle + 2 * Math.PI;
				}
				if (p1Angle < 0) {
					p1Angle + 2 * Math.PI;
				}
			}
			function findMin(num1, num2) {
				return num1 > num2 ? num2 : num1;
			}
			function animate() {
				/*
			let cameraPos = new THREE.Vector3(-30, 15, 0);
			soldier.mesh.children[2].localToWorld(cameraPos);
			camera.position.copy(cameraPos);
			let cameraLookAt = new THREE.Vector3(0, 2, 0);
			soldier.mesh.children[2].localToWorld(cameraLookAt);
			camera.lookAt(cameraLookAt);*/

				animate.distance = animate.distance ? animate.distance : 0;

				keyboard.update();
				checkAim();
				SoldierMoving();
				SoldierShooting();
				ShootThrough();

				bullets.forEach(function (data) {
					data.bullet.position.add(
						data.direction.clone().setLength(10)
					);
				});

				let dt = clock.getDelta();
				let time = clock.getElapsedTime();
				soldier.update(dt);
				prey.update(dt, time);
				prey.findTarget(flag);

				var dst = prey.pos.distanceTo(flag.position);
				var disToSoldier = prey.pos.distanceTo(soldier.pos);

				var c = new THREE.Mesh();
				c.position.set(
					nearObstacle().mesh.position.x,
					0,
					nearObstacle().mesh.position.z
				);

				let point = new THREE.Mesh();
				point.position.set(120, 0, 0);

				if (
					Math.abs(soldier.pos.x - flag.position.x) < 5 &&
					Math.abs(soldier.pos.z - flag.position.z) < 5 &&
					get === false &&
					insert === false &&
					end === false
				) {
					flag.position.set(soldier.pos.x, 10, soldier.pos.z);
					soldierFlag = true;
				} else {
					soldierFlag = false;
				}

				if (soldierFlag === false) {
					if (disToSoldier < 100 && seeWarrior === true) {
						already -= 1;

						get = false;
						attack = true;
						prey.fsm.attacked();

						var p = findP(c);
						findHidePlace(c, p);
					} else if (second > 6) {
						already = 1;

						attack = false;
						if (get === true || insert === true) {
							prey.fsm.takeFlag();
						} else if (dst < 200 && front === true) {
							prey.fsm.seeFlag();
						} else {
							/*if (dst >= 200 && front === false && get === false) */
							prey.fsm.findFlag();
						}
					}
				}
				if (soldierFlag === true) {
					prey.fsm.defense();
				}
				if (
					Math.abs(prey.pos.x - point.position.x) < 5 &&
					Math.abs(prey.pos.z - point.position.z) < 5
				) {
					end = true;
					prey.setBrake(10);
				}
				animate.distance = dst;
				// 讓「帥蓋」方位永遠固定
				soldier.mesh.children[0].quaternion.copy(
					soldier.mesh.quaternion.clone().invert()
				);
				// 讓「車蓋」方位永遠固定
				prey.mesh.children[0].quaternion.copy(
					prey.mesh.quaternion.clone().invert()
				);

				renderer.clear(true);
				renderer.render(scene, camera);
				if (zoom) renderer.render(hudScene, hudCamera);

				requestAnimationFrame(animate);
			}
		</script>
	</body>
</html>
