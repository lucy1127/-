<!DOCTYPE html>
<html>
	<head>
		<style>
			body {
				overflow: hidden
			}
			#heading {
				text-align: center;
				position: absolute;
				width: 100vw;
			}
			#btn {
				position: absolute;
				top: 300px;
			}

			#lifebtn {
				position: absolute;
				width: 10px;
				height: 10px;
				text-align: left;
				
			}
			
			#manu {
				display: none;
				width: 400px;
				height: 200px;
				margin-left: 10px;
				background-color: #ffffe0;
				border-radius: 30px;
				text-align: left;
				opacity: 0.5;
			}
			
			#closeBtn {
				margin-left: 320px;
				margin-top : 150px;
			}
			

			#start {
				position: absolute;
				top: 440px;
				font-size: 60px;
				width: 100%;
				padding: 5px;
				text-align: center;
				color: #ffff00;
			}
			#end {
				position: absolute;
				top: 440px;
				font-size: 60px;
				width: 100%;
				padding: 5px;
				text-align: center;
				color: #ffff00;
			}
			#restart {
				position: absolute;
				top: 500px;
				font-size: 60px;
				width: 100%;
				padding: 5px;
				text-align: center;
				color: #ffff00;
			}
		</style>
		<link rel="stylesheet" href="hp.css">
		
	</head>
	<body>
		<div id="heading">
			<h3 style="color: red">Version 0.0-2 <br /></h3>
			<button id = 'toggle'>Switch View </button>
		
		</div>
		
		<div id = "btn">
			<p class="lifebtn" onclick= "life()">
				<input
					type="button"
					style="
						width: 50px;
						height: 50px;
						background-image: url('https://i.imgur.com/pyKoKxw.png');						
						background-size: 45px 45px;
					"
				/>
			</p>
		
			<div id="manu">
				<div class="hpBar">
					
					<h2>
						<img src = "capturer.png" width = "40" height = "35"/> 
					</h2>
					<div class="hpBox">
						<div class="hp"></div>
					</div>
				</div>
				<div id = "heartCap">	
					<script>
						
							
							document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40"> ');
							document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40"> ');
							document.write('<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40"> ');
						
					</script>
				</div>
				
				
				
				<button id = "closeBtn" onclick = "lifeclose()">CLOSE</button>	
			</div>
		</div>
			
		
		<script src="life.js"></script>
		<script src="state-machine.js"></script>
		<script src="https://threejs.org/build/three.min.js"></script>
		<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
		<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
		
		
		
		<div id="start"></div>
		<div id="end"></div>
		<div id="restart"></div>

		<script type="module">
			import { MTLLoader } from "https://threejs.org/examples/jsm/loaders/MTLLoader.js";
			import { OBJLoader } from "https://threejs.org/examples/jsm/loaders/OBJLoader.js";


			import * as THREE from "https://threejs.org/build/three.module.js";
			import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";

			(function () {
				Math.clamp = function (val, min, max) {
					return Math.min(Math.max(val, min), max);
				};
			})();

			

			class Avatar {
				constructor(pos, mesh) {
					/*this.pos = pos.clone();
					this.vel = new THREE.Vector3();
					this.force = new THREE.Vector3();
					this.MAXSPEED = 50;
					this.ARRIVAL_R = 150;

					this.size = 35;
					this.angle = 0; // for orientable agent
					this.mesh = mesh;
					scene.add(mesh);

					this.target = null;
					this.steermode = "";
					this.BRAKING = 0; // no brake*/
                    
                    
                    
                    this.pos = pos.clone();
					this.vel = new THREE.Vector3();
					this.force = new THREE.Vector3();
					this.MAXSPEED = 50;
					this.ARRIVAL_R = 30;

					this.target = null;
					this.steermode = "";
					this.BRAKING = 0;
					this.size = 25;
					this.mesh = mesh;
					scene.add(mesh);

					// for orientable agent
					this.angle = 0;
				}

				update(dt) {
					//console.log ('in avatar update ...');

					this.accumulateForce();
					this.vel.add(this.force.clone().multiplyScalar(dt));

					// ARRIVAL: velocity modulation
					if (this.target !== null) {
						let diff = this.target.clone().sub(this.pos);
						let dst = diff.length();
						if (dst < this.ARRIVAL_R) {
							this.vel.setLength(dst);
						}
					}

					//Obstacle
					let obs = scene.obstacles;
					// pick the most threatening one
					let theOne = null;
					let dist = 1e10;
					let vhat = this.vel.clone().normalize();
					const REACH = 50;
					const K = 5;
					let perp;
					for (let i = 0; i < obs.length; i++) {
						let point = obs[i].center.clone().sub(this.pos); // c-p
						let proj = point.dot(vhat);
						if (proj > 0 && proj < REACH) {
							perp = new THREE.Vector3();
							perp.subVectors(
								point,
								vhat.clone().setLength(proj)
							);
							let overlap =
								obs[i].size + this.size - perp.length();
							if (overlap > 0 && proj < dist) {
								theOne = obs[i];
								dist = proj;
								perp.setLength(K * overlap);
								perp.negate();
							}
						}
					}
					if (theOne) this.force.add(perp);

					this.vel.add(this.force.clone().multiplyScalar(dt));

					// MAXSPEED modulation
					let speed = this.vel.length();
					this.vel.setLength(Math.clamp(speed, 0, this.MAXSPEED));
					this.pos.add(this.vel.clone().multiplyScalar(dt));
					this.mesh.position.copy(this.pos);

					// for orientable agent
					if (this.vel.length() > 2.0) {
						this.angle = Math.atan2(-this.vel.z, this.vel.x);
						this.mesh.rotation.y = this.angle;
					}
				}

				setSeekTarget(x, y, z) {
					this.BRAKING = 0; // release Brake while seek
					this.steerMode = "SEEK";
					this._setTarget(x, y, z);
				}

				// target, Patrol & Hide
				setPatrolTarget(x, y, z) {
					this.BRAKING = 0;
					this.steerMode = "patrol";
					this._setTarget(x, y, z);
				}

				setAttackTarget(x, y, z) {
					this.BRAKING = 0;
					this.steerMode = "attack";
					//this._setTarget (x,y,z);
				}

				setHideTarget(x, y, z) {
					this.BRAKING = 0;
					this.steerMode = "hide";
					this._setTarget(x, y, z);
				}


				setFleeTarget(x, y, z) {
					this.BRAKING = 0;
					this.steerMode = "FLEE";
					this._setTarget(x, y, z);
				}
				setFollowTarget(x, y, z) {
					this.BRAKING = 0;
					this.steerMode = "FOLLOW";
					this._setTarget(x, y, z);
				}

				_setTarget(x, y, z) {
					// do not use directly
					if (this.target !== null) this.target.set(x, y, z);
					else {
						this.target = new THREE.Vector3(x, y, z);
					}
				}

				targetInducedForce(targetPos) {
					let sign = 0;
					if (
						this.steerMode === "patrol" ||
						this.steerMode === "SEEK" ||
						this.steerMode === "FOLLOW"
					)
						sign = 1;
					else if (
						this.steerMode === "hide" ||
						this.steerMode === "FLEE"
					)
						sign = -1;

					return targetPos
						.clone()
						.sub(this.pos)
						.normalize()
						.multiplyScalar(sign * this.MAXSPEED)
						.sub(this.vel);
				}

				setBrake(brake) {
					// make the avatar stop gracefully
					this.BRAKING = brake;
					this.target = null; // release target
				}

				accumulateForce() {
					if (this.target)
						this.force.copy(this.targetInducedForce(this.target));
					else this.force.set(0, 0, 0); // for null-target initial force

					// braking ...
					this.force.add(
						this.vel.clone().multiplyScalar(-this.BRAKING)
					);
				}
			}
			class PreditorAgent extends Avatar {
				constructor(pos, mesh, name = "", fsm) {
					super(pos, mesh);
					this.fsm = fsm;
					this.stateSign = null;
				}
				update(dt) {
					super.update(dt); // calling avatar update

					// agent related ...
					// how to make the brain not so hyper-active
					if (this.fsm) {
						$("#preditorState").text(this.fsm.state);

						if (this.fsm.state === "hide") {
							/*super.setSeekTarget(
								30 * Math.cos((pAngle + p1Angle) / 2) +
									nearObstacle().center.x,
								0,
								30 * Math.sin((pAngle + p1Angle) / 2) +
									nearObstacle().center.z
							);
							circleA.rotation.x = -Math.PI / 2;
							circleA.position.set(
								30 * Math.cos((pAngle + p1Angle) / 2) +
									nearObstacle().center.x,
								0,
								30 * Math.sin((pAngle + p1Angle) / 2) +
									nearObstacle().center.z
							);*/
							super.setHideTarget(
								soldier.pos.x,
								soldier.pos.y,
								soldier.pos.z
							);
							this.mesh.children[0].material.visible = false;
							this.mesh.children[1].material.visible = false;
							this.mesh.children[2].material.visible = true;
						}
						if (this.fsm.state === "patrol") {
							let dt = clock.getElapsedTime();

							if (dt > 8) {
								let back = preditor.mesh.localToWorld(
									new THREE.Vector3(20, 0, -20)
								);
								super.setPatrolTarget(back.x, 0, back.z);
								$("#Check").text("Check Behind");
							} else {
								let dis = prey.mesh.localToWorld(
									new THREE.Vector3(-30, 0, 30)
								);
								super.setPatrolTarget(dis.x, 0, dis.z);
								$("#Check").text("Follow Capturer");
							}
							//console.log(dt);

							this.mesh.children[0].material.visible = true;
							this.mesh.children[1].material.visible = false;
							this.mesh.children[2].material.visible = false;
						}
						if (this.fsm.state === "attack") {
							super.setBrake(10);
							clock.elapsedTime = 0;

							this.mesh.children[0].material.visible = false;
							this.mesh.children[1].material.visible = true;
							this.mesh.children[2].material.visible = false;
						}
					}

					if (preditor.stateSign) {
						preditor.stateSign.position.copy(preditor.pos);
						preditor.stateSign.position.y = 10;
						preditor.stateSign.lookAt(
							camera.position.x,
							50,
							camera.position.z
						);

						if (preditor.fsm.state === "patrol") {
							preditor.stateSign.children[0].material.visible = true;
							preditor.stateSign.children[1].material.visible = false;
							preditor.stateSign.children[2].material.visible = false;
						}
						if (preditor.fsm.state === "hide") {
							preditor.stateSign.children[1].material.visible = true;
							preditor.stateSign.children[0].material.visible = false;
							preditor.stateSign.children[2].material.visible = false;
						}
						if (preditor.fsm.state === "attack") {
							preditor.stateSign.children[0].material.visible = false;
							preditor.stateSign.children[1].material.visible = false;
							preditor.stateSign.children[2].material.visible = true;
						}
					}
				}
			}
			class CapturerAgent extends Avatar {
				constructor(pos, mesh, name = "", fsm) {
					super(pos, mesh);
					this.fsm = fsm;
					// initial state got from fsm.state;
					this.stateSign = null;
				}

				update(dt, time) {
					if (this.pos.z >= 200) {
						this.pos.z = 200;
					} else if (this.pos.z <= -200) {
						this.pos.z = -200;
					} else if (this.pos.x >= 200) {
						this.pos.x = 200;
					} else if (this.pos.x <= -200) {
						this.pos.x = -200;
					}
					super.update(dt); // calling avatar update
					if (this.fsm) {
						$("#preyState").text(this.fsm.state);

						if (this.fsm.state === "snatch") {
							super.setSeekTarget(
								flag.position.x,
								0,
								flag.position.z
							);

							if (
								Math.abs(flag.position.x - this.pos.x) < 5 &&
								Math.abs(flag.position.z - this.pos.z) < 5
							) {
								get = true;
								insert = true;
							}
						}
						if (this.fsm.state === "search") {
							var angleSearch, nextTargetX, nextTargetZ;
							var nextTarget, allOk;
							angleSearch = Math.random() * Math.PI * 2;
							nextTarget = this.mesh.localToWorld(
								new THREE.Vector3(
									75 * Math.cos(angleSearch),
									0,
									75 * Math.sin(angleSearch)
								)
							);
							can = false;

							for (var i = 1; i < scene.obstacles.length; i++) {
								if (
									nextTarget.distanceTo(
										scene.obstacles[i].center
									) > scene.obstacles[i].size
								) {
									allOk = true;
								} else {
									allOk = false;
								}
							}
							if (
								nextTarget.x < 190 &&
								nextTarget.x > -190 &&
								nextTarget.z < 190 &&
								nextTarget.z > -190 &&
								allOk === true
							) {
								can = true;
							} else {
								can = false;
								nextTarget = this.mesh.localToWorld(
									new THREE.Vector3(
										75 * Math.cos(angleSearch),
										0,
										75 * Math.sin(angleSearch)
									)
								);
							}

							if (can === true && time < 1) {
								nextTargetCircle.position.set(
									nextTarget.x,
									0,
									nextTarget.z
								);

								super.setSeekTarget(
									nextTarget.x,
									0,
									nextTarget.z
								);
							}
							//super.setBrake(10);
						}

						if (this.fsm.state === "hide") {
							insert = false;
							var obstacle = new THREE.Vector3(
								nearObstacle().center.x,
								0,
								nearObstacle().center.z
							);
							var finalOrientation = new THREE.Quaternion();
							var x =
								35 * Math.cos((pAngle + p1Angle) / 2) +
								obstacle.x;
							var z =
								35 * Math.sin((pAngle + p1Angle) / 2) +
								obstacle.z;
							super.setSeekTarget(x, 0, z);
							/*if (
								Math.abs(this.pos.x - x) < 1 &&
								Math.abs(this.pos.z - z) < 1
							) {
								//hideTurn = true;

								var angleNow = Math.atan2(
									x - obstacle.x,
									z - obstacle.z
								);
								angleNow -= Math.PI / 2;

								finalOrientation.setFromEuler(
									new THREE.Euler(0, angleNow, 0)
								);
								this.mesh.quaternion.rotateTowards(
									finalOrientation,
									0.01
								);
							}*/
						}
						if (this.fsm.state === "touchDown") {
							if (get === true) {
								flag.position.set(this.pos.x, 10, this.pos.z);
							}
							if (insert === true) {
								super.setSeekTarget(175, 0, 175);
							}
						}
						if (this.fsm.state === "endGame") {
							super.setSeekTarget(-90, 0, -90);
						}
						//hideTurn = false;
					}
					if (this.stateSign) {
						this.stateSign.position.copy(this.pos);
						this.stateSign.position.y = 30;
						this.stateSign.lookAt(
							camera.position.x,
							10,
							camera.position.z
						);

						if (this.fsm.state === "snatch") {
							this.stateSign.children[0].material.visible = true;
							this.stateSign.children[1].material.visible = false;
							this.stateSign.children[2].material.visible = false;
							this.stateSign.children[3].material.visible = false;
							nextTargetCircle.material.visible = false;
							this.mesh.children[12].material.visible = false;
							this.mesh.children[1].position.x = 3;
							this.mesh.children[2].material.visible = true;
							this.mesh.children[11].material.visible = true;
							this.mesh.children[6].material.visible = false;
							this.mesh.children[3].material.visible = false;
							this.mesh.children[4].material.visible = false;
							this.mesh.children[5].material.visible = false;
							this.mesh.children[7].material.visible = false;
							this.mesh.children[8].material.visible = false;
							this.mesh.children[9].material.visible = false;
							this.mesh.children[10].material.visible = false;

							this.mesh.children[0].children[0].material.visible = true;
							this.mesh.children[0].children[1].material.visible = false;
							this.mesh.children[0].children[2].material.visible = false;
							this.mesh.children[0].children[3].material.visible = false;
						}
						if (this.fsm.state === "search") {
							this.stateSign.children[1].material.visible = true;
							this.stateSign.children[0].material.visible = false;
							this.stateSign.children[2].material.visible = false;
							this.stateSign.children[3].material.visible = false;

							if (time < 1) {
								this.mesh.children[12].material.visible = true;
							} else {
								this.mesh.children[12].material.visible = false;
							}

							if (Math.floor(time) === 2) {
								nextTargetCircle.material.visible = true;
							} else {
								nextTargetCircle.material.visible = false;
							}
							this.mesh.children[1].position.x = 3;
							this.mesh.children[6].material.visible = true;
							this.mesh.children[7].material.visible = true;
							this.mesh.children[3].material.visible = false;
							this.mesh.children[4].material.visible = false;
							this.mesh.children[5].material.visible = false;
							this.mesh.children[2].material.visible = false;
							this.mesh.children[11].material.visible = false;
							this.mesh.children[8].material.visible = false;
							this.mesh.children[9].material.visible = false;
							this.mesh.children[10].material.visible = false;

							this.mesh.children[0].children[3].material.visible = true;
							this.mesh.children[0].children[1].material.visible = false;
							this.mesh.children[0].children[2].material.visible = false;
							this.mesh.children[0].children[0].material.visible = false;
						}
						if (this.fsm.state === "hide") {
							this.stateSign.children[2].material.visible = true;
							this.stateSign.children[0].material.visible = false;
							this.stateSign.children[1].material.visible = false;
							this.stateSign.children[3].material.visible = false;
							nextTargetCircle.material.visible = false;
							this.mesh.children[12].material.visible = false;

							if (Math.round(time * 16) % 2 === 0) {
								this.mesh.children[3].material.visible = true;
								this.mesh.children[2].material.visible = false;
								this.mesh.children[0].children[1].material.visible = true;
								this.mesh.children[0].children[0].material.visible = false;
							} else {
								this.mesh.children[2].material.visible = true;
								this.mesh.children[3].material.visible = false;
								this.mesh.children[0].children[1].material.visible = false;
								this.mesh.children[0].children[0].material.visible = true;
							}

							this.mesh.children[1].position.x = 3;
							//this.mesh.children[3].material.visible = true;
							this.mesh.children[8].material.visible = true;
							this.mesh.children[4].material.visible = false;
							//this.mesh.children[2].material.visible = false;
							this.mesh.children[5].material.visible = false;
							this.mesh.children[6].material.visible = false;
							this.mesh.children[11].material.visible = false;
							this.mesh.children[7].material.visible = false;
							this.mesh.children[9].material.visible = false;
							this.mesh.children[10].material.visible = false;

							//this.mesh.children[0].children[1].material.visible = true;
							this.mesh.children[0].children[2].material.visible = false;
							//this.mesh.children[0].children[0].material.visible = false;
							this.mesh.children[0].children[3].material.visible = false;
						}
						if (this.fsm.state === "touchDown") {
							this.stateSign.children[3].material.visible = true;
							this.stateSign.children[0].material.visible = false;
							this.stateSign.children[1].material.visible = false;
							this.stateSign.children[2].material.visible = false;
							nextTargetCircle.material.visible = false;
							this.mesh.children[12].material.visible = false;
							if (Math.round(time * 4) % 2 === 0) {
								this.mesh.children[4].material.visible = true;
								this.mesh.children[2].material.visible = false;
								this.mesh.children[0].children[2].material.visible = true;
								this.mesh.children[0].children[0].material.visible = false;
							} else {
								this.mesh.children[2].material.visible = true;
								this.mesh.children[4].material.visible = false;
								this.mesh.children[0].children[2].material.visible = false;
								this.mesh.children[0].children[0].material.visible = true;
							}

							//this.mesh.children[4].material.visible = true;
							this.mesh.children[9].material.visible = true;
							this.mesh.children[3].material.visible = false;
							//this.mesh.children[2].material.visible = false;
							this.mesh.children[5].material.visible = false;
							this.mesh.children[6].material.visible = false;
							this.mesh.children[11].material.visible = false;
							this.mesh.children[7].material.visible = false;
							this.mesh.children[8].material.visible = false;
							this.mesh.children[10].material.visible = false;

							//this.mesh.children[0].children[2].material.visible = true;
							//this.mesh.children[0].children[0].material.visible = false;
							this.mesh.children[0].children[1].material.visible = false;
							this.mesh.children[0].children[3].material.visible = false;
						}
						if (this.fsm.state === "endGame") {
							this.stateSign.children[3].material.visible = true;
							this.stateSign.children[0].material.visible = false;
							this.stateSign.children[1].material.visible = false;
							this.stateSign.children[2].material.visible = false;
							nextTargetCircle.material.visible = false;
							this.mesh.children[12].material.visible = false;

							this.mesh.children[5].material.visible = true;
							this.mesh.children[3].material.visible = false;
							this.mesh.children[2].material.visible = false;
							this.mesh.children[4].material.visible = false;
						}
					}
				}
				/*straight() {
					start = true;
					setTimeout(this.straight(), 5000);
				}*/

				findTarget(target) {
					var point = target.position.clone().sub(this.pos);
					var pointWarrior = soldier.pos
						.clone()
						.sub(this.pos)
						.normalize();

					var preyDirect = this.mesh
						.localToWorld(new THREE.Vector3(1, 0, 0))
						.sub(this.mesh.localToWorld(new THREE.Vector3(0, 0, 0)))
						.normalize();
					var CosineValueWarrior = pointWarrior.dot(preyDirect);

					ray.set(this.pos, pointWarrior);
					//debugger;
					var intersects = ray.intersectObjects(pickables2, true);
					if (intersects.length > 0) {
						if (
							intersects[0].object.name ===
								soldier.mesh.children[2].name &&
							CosineValueWarrior > 0
						) {
							seeWarrior = true;
						} else seeWarrior = false;
					}

					var CosineValue = point.dot(preyDirect);

					if (CosineValue > 0) {
						front = true;
					} else {
						front = false;
					}
				}
			}
			class DefAgent extends Avatar {
				constructor(pos, mesh, name = "", fsm) {
					super(pos, mesh);
					this.fsm = fsm;
					this.name = name;
					// initial state got from fsm.state;
					this.stateSign = null;
				}

				update(dt) {
					super.update(dt); // calling avatar update
					if (this.fsm) {
						$("#defenseState").text(this.fsm.state);

						if (this.fsm.state === "follow") {
							if (this.name === "defR") {
								let pointfR = prey.mesh.localToWorld(
									new THREE.Vector3(-10, 0, 15)
								);
								super.setFollowTarget(
									pointfR.x,
									pointfR.y,
									pointfR.z
								);

								this.mesh.children[0].material.visible = true;
								this.mesh.children[1].material.visible = false;
							} else if (this.name === "def") {
								let pointf = prey.mesh.localToWorld(
									new THREE.Vector3(-20, 0, 0)
								);
								super.setFollowTarget(
									pointf.x,
									pointf.y,
									pointf.z
								);

								this.mesh.children[0].material.visible = true;
								this.mesh.children[1].material.visible = false;
							} else if (this.name === "defL") {
								let pointfL = prey.mesh.localToWorld(
									new THREE.Vector3(-10, 0, -15)
								);
								super.setFollowTarget(
									pointfL.x,
									pointfL.y,
									pointfL.z
								);
								this.mesh.children[0].material.visible = true;
								this.mesh.children[1].material.visible = false;
							}
						}
						if (this.fsm.state === "defense") {
							if (this.name === "defR") {
								let pointdR = prey.mesh.localToWorld(
									new THREE.Vector3(15, 0, 15)
								);
								super.setFollowTarget(
									pointdR.x,
									pointdR.y,
									pointdR.z
								);

								this.mesh.children[0].material.visible = false;
								this.mesh.children[1].material.visible = true;
							} else if (this.name === "def") {
								let pointd = prey.mesh.localToWorld(
									new THREE.Vector3(-20, 0, 0)
								);
								super.setFollowTarget(
									pointd.x,
									pointd.y,
									pointd.z
								);

								this.mesh.children[0].material.visible = false;
								this.mesh.children[1].material.visible = true;
							} else if (this.name === "defL") {
								let pointdL = prey.mesh.localToWorld(
									new THREE.Vector3(15, 0, -15)
								);
								super.setFollowTarget(
									pointdL.x,
									pointdL.y,
									pointdL.z
								);

								this.mesh.children[0].material.visible = false;
								this.mesh.children[1].material.visible = true;
							}
						}
					}
					//頭上的狀態
					if (this.stateSign) {
						this.stateSign.position.copy(this.pos);
						this.stateSign.position.y = 10;
						this.stateSign.lookAt(
							camera.position.x,
							15,
							camera.position.z
						);

						if (this.fsm.state === "follow") {
							this.stateSign.children[0].material.visible = true;
							this.stateSign.children[1].material.visible = false;
						}
						if (this.fsm.state === "defense") {
							this.stateSign.children[1].material.visible = true;
							this.stateSign.children[0].material.visible = false;
						}
					}
				}
			}
            class SoldierAgent extends Avatar {
				
                
                constructor(pos, mesh, name = "", fsm) {
					super(pos, mesh);
					this.fsm = fsm;
					this.name = name;
					// initial state got from fsm.state;
					this.stateSign = null;
				}

				update(dt) {
					if (this.pos.z >= 200) {
						this.pos.z = 200;
					} else if (this.pos.z <= -200) {
						this.pos.z = -200;
					} else if (this.pos.x >= 200) {
						this.pos.x = 200;
					} else if (this.pos.x <= -200) {
						this.pos.x = -200;
					}
					super.update(dt); // calling avatar update
				}

				findTarget() {
					var pointCapturer = prey.pos
						.clone()
						.sub(this.pos)
						.normalize();

					var soldierDirect = this.mesh
						.localToWorld(new THREE.Vector3(1, 0, 0))
						.sub(this.mesh.localToWorld(new THREE.Vector3(0, 0, 0)))
						.normalize();
					var CosineValueCapturer = pointCapturer.dot(soldierDirect);
					if (CosineValueCapturer > 0) {
						seeCapturer = true;
					} else seeCapturer = false;
				}
			}
			class Obstacle {
				constructor(center, size) {
					this.center = center.clone();
					let loader = new THREE.TextureLoader();
					loader.crossOrigin = "";
					let texture = loader.load(
						"https://i.imgur.com/XlAVV7B.jpg"
					);

					var texMat = new THREE.MeshBasicMaterial({
						map: texture,
						side: THREE.DoubleSide,
					});
					this.mesh = new THREE.Mesh(
						new THREE.CylinderGeometry(size, size, 20, 64),
						texMat
					);
					this.mesh.position.copy(center);
					this.size = size;
					scene.add(this.mesh);
				}
			}

			//preditor
			var camera, scene, renderer, clock;
			var preditor, prey, soldier;
			var pickables = [];
			var raycaster = new THREE.Raycaster();
			var mouse = new THREE.Vector2();
			var preditorRaycaster;
			var theta = 0,
				HH = 12;
			var hide = false;
			//prey
			var keyboard = new KeyboardState();
			var ray;
			var mouse = new THREE.Vector2();
			var pickables2 = [];
			var front = false,
				hidden = false;
			var count = 0;
			var flag;
			var get = false,
				insert = false,
				attack = false;
			var circleL, circleR;
			var pAngle, p1Angle;
            var can = false;
            var seeWarrior = false,seeCapturer = false;
            var nextTargetCircle;
            var soldierFlag = false;
            var second = 0;
            var already = 1;
			//defends
			var intersects;
			var agents = [];
			var defenseL, defense, defenseR;
			var point;
			var stop = false;
            var time;
			//介面
			var state = -1;
			var start, end, restart;
			
			//蟲洞
			var respawnPos,respawnPos1,tunnel,rebir,rebir2;
			//射擊
			var bullets = [],solattack,solattack2;
			//生命值
			var ATTACK = 50;
			var Hp = 100;
			var lifeNum = 3;
			
			//視角
			var isSwitch = false;
			var inHUD = false;
			
			//戰士移動
			var movepos = new THREE.Vector3(170,0,170);
			var movevel = new THREE.Vector3();
			var moveforce = new THREE.Vector3();
			var angle,power;
			
			//小視窗
			var cameraHUD2,sceneHUD,cameraHUD1;
            
			//瞄準
			var hudCamera,hudScene,zoom = false;
			var renderer1;
			
            $('#toggle').click (

			   function() {
					isSwitch = ! isSwitch;  // toggle
						
					if(!isSwitch){
						camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
						camera.position.z = 500;
						let controls = new OrbitControls(camera, renderer.domElement);
					}
				}
			);
			
			
			init();
			animate();
			
			
			
			function preditorFSM() {
				let fsm = new StateMachine({
					init: "patrol",
					transitions: [
						{ name: "beattacked", from: "patrol", to: "hide" },
						{ name: "beattacked", from: "hide", to: "hide" },
						{ name: "depart", from: "hide", to: "patrol" },
						{ name: "depart", from: "attack", to: "hide" },
						{ name: "depart", from: "patrol", to: "patrol" },
						{ name: "shoot", from: "patrol", to: "attack" },
						{ name: "shoot", from: "attack", to: "attack" },
					],
				});
				return fsm;
			}
			function preyFSM() {
				let fsm = new StateMachine({
					init: "search",
					transitions: [
						{ name: "seeFlag", from: "search", to: "snatch" },
						{ name: "seeFlag", from: "snatch", to: "snatch" },
						{ name: "seeFlag", from: "hide", to: "snatch" },

						//{ name: "findFlag", from: "snatch", to: "search" },
						{ name: "findFlag", from: "hide", to: "search" },
						{ name: "findFlag", from: "search", to: "search" },
						{ name: "findFlag", from: "endGame", to: "search" },
						{ name: "attacked", from: "snatch", to: "hide" },
						{ name: "attacked", from: "search", to: "hide" },
						{ name: "attacked", from: "touchDown", to: "hide" },
						{ name: "attacked", from: "hide", to: "hide" },
						{ name: "takeFlag", from: "snatch", to: "touchDown" },
						{
							name: "takeFlag",
							from: "touchDown",
							to: "touchDown",
						},
						{ name: "defense", from: "endGame", to: "endGame" },
						{ name: "defense", from: "snatch", to: "endGame" },
						{ name: "defense", from: "search", to: "endGame" },
						{ name: "defense", from: "hide", to: "endGame" },
                        { name: "restart", from: "touchDown", to: "search" },
						{ name: "restart", from: "search", to: "search" },
					],
				});
				return fsm;
			}
			function garrisonFSM() {
				let fsm = new StateMachine({
					init: "follow",
					transitions: [
						{ name: "attack", from: "follow", to: "defense" },
						{ name: "attack", from: "defense", to: "defense" },
						{ name: "noattack", from: "defense", to: "follow" },
						{ name: "noattack", from: "follow", to: "follow" },
					],
				});

				return fsm;
			}

			//小視窗
			function initHUD() {
				  // sceneHUD: a simple line boundary
				  sceneHUD = new THREE.Scene();
				  cameraHUD1 = new THREE.OrthographicCamera(-10.5, 10.5, 10.5, -10.5, -50, 50);
				  cameraHUD1.position.z = 20;  // for border
				  
				  //小視窗
				cameraHUD2 = new THREE.OrthographicCamera(-220,220,220,-220,-420,420);
				cameraHUD2.position.set (0,30,0)
				cameraHUD2.up.set (0,0,-1)   // for top view
				cameraHUD2.lookAt (new THREE.Vector3())

				  let points = [];
				  points.push (
					new THREE.Vector3(-10, -10, 0),
					new THREE.Vector3(10, -10, 0),
					new THREE.Vector3(10, 10, 0),
					new THREE.Vector3(-10, 10, 0),
					new THREE.Vector3(-10, -10, 0));
				  var lineGeometry = new THREE.BufferGeometry().setFromPoints (points);
					
				  var line = new THREE.Line(lineGeometry,
					new THREE.LineBasicMaterial({
					  color: 0xffffff
					}));
				  sceneHUD.add(line);
			  
			}
			
			function init() {
				clock = new THREE.Clock();
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(
					50,
					window.innerWidth / window.innerHeight,
					1,
					1000
				);
				camera.position.z = 120;
				camera.position.y = 100;

				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(0x888888);
				renderer.autoClear = false;
				
				renderer1 = new THREE.WebGLRenderer();
				renderer1.setSize(window.innerWidth, window.innerHeight);
				renderer1.setClearColor(0x888888);
				renderer1.autoClear = false;

				//介面
				start = document.getElementById("start");
				start.innerHTML = "Press enter to begin";

				end = document.getElementById("end");
				restart = document.getElementById("restart");
				

				let controls = new OrbitControls(camera, renderer.domElement);
				document.body.appendChild(renderer.domElement);
				window.addEventListener("resize", onWindowResize, false);
				var gridXZ = new THREE.GridHelper(400, 40, "red", "white");
				scene.add(gridXZ);

				document.addEventListener(
					"pointerdown",
					onDocumentMouseDown,
					false
				);
                
				//////////////////////////////////////////////////////////////////////////////////////////
				var cubeMap = loadCubemap();
				scene.background = cubeMap;
				
				var ground = new THREE.Mesh(
					new THREE.PlaneGeometry(50, 50, 32),
					new THREE.MeshBasicMaterial({
						color: 0xff0000,
						transparent: true,
						opacity: 0.3,
					})
				);
				ground.rotation.x = -Math.PI / 2;
				ground.rotation.z = Math.PI / 2;
				ground.position.set(-175, 0, -175);

				var ground1 = ground.clone();
				ground1.position.set(175, 0, 175);

				var startpos = new THREE.Mesh(
					new THREE.CircleGeometry(10, 32),
					new THREE.MeshBasicMaterial({
						color: "yellow",
						transparent: true,
						opacity: 0.3,
						side: THREE.DoubleSide,
					})
				);
				startpos.rotation.x = -Math.PI / 2;
				//////////////////////////////////////////////////////////////////////////////////////////
				////蟲洞//////
				rebir = rebirth(8,18);
				rebir2 = rebir.clone();
				//rebir2.rotation.y = Math.PI/2;
				
				scene.add(rebir,rebir2);
				rebir.position.set(-200,20,-170);
				rebir2.position.set(200,20,170);
				
				
				
	
				//////////////////////////////////////////////////////////////////////////////////////////
				var flagPoint = new THREE.Mesh(
					new THREE.CircleGeometry(5, 32),
					new THREE.MeshBasicMaterial({
						color: "red",
						side: THREE.DoubleSide,
					})
				);
				flagPoint.rotation.x = -Math.PI / 2;

				flagPoint.position.set(-175, 1, -175);

				var flagPoint1 = flagPoint.clone();
				flagPoint1.position.set(175, 1, 175);
				scene.add(
					ground,
					ground1,
					flagPoint,
					flagPoint1
				);
				//////////////////////////////////////////////////////////////////////////////////////////
				let plane = new THREE.Mesh(
					new THREE.PlaneGeometry(400, 400),
					new THREE.MeshBasicMaterial({
						transparent: true,
						opacity: 0.5,
						visible: true,
					})
				);
				scene.add(plane);
				plane.material.visible = false;
				plane.rotation.x = -Math.PI / 2;
				pickables = [plane];
				
				//pickables.push(prey);
				///////////////////////////////////////////////////////////////////////////////////////////
				/*preditor = new PreditorAgent(
					new THREE.Vector3(-175, 0, -175),
					preditorMesh(),
					"T-Rex",
					preditorFSM()
				);*/
				
				prey = new CapturerAgent(
					new THREE.Vector3(190, 20, -170),
					capturerMesh(),
					"sheep",
					preyFSM()
				);
				prey.stateSign = stateSign();

				soldier = new SoldierAgent(
					new THREE.Vector3(170, 0, 170),
					soldierMesh(),
					"soldier"
				);

				let defmeshR = DefMesh();
				let defmesh = DefMesh();
				let defmeshL = DefMesh();
				/*defenseR = new DefAgent(
					new THREE.Vector3(-175, 0, -175),
					defmeshR,
					"defR",
					garrisonFSM()
				);
				defense = new DefAgent(
					new THREE.Vector3(-175, 0, -175),
					defmesh,
					"def",
					garrisonFSM()
				);
				defenseL = new DefAgent(
					new THREE.Vector3(-175, 0, -175),
					defmeshL,
					"defL",
					garrisonFSM()
				);*/
				agents.push(//defenseL, defense, defenseR, 
					prey);
				

				//add obstacles to the scene
				scene.obstacles = [];
				

				preditorRaycaster = new THREE.Raycaster();
				raycaster = new THREE.Raycaster();
				ray = new THREE.Raycaster();
			
				//flag
				let loader = new THREE.TextureLoader();
				loader.crossOrigin = "";
				let tex = loader.load("https://i.imgur.com/3YSMhL0.png");
				flag = new THREE.Mesh(
					new THREE.CircleGeometry(10, 20),
					new THREE.MeshBasicMaterial({
						map: tex,
						transparent: true,
						side: THREE.DoubleSide,
					})
				);
				var x = Math.random() * 380 - 190;
				flag.position.set(x, 8, -x);

				scene.add(flag);
				flag.name = "flag";
				//pickables2.push(flag);
				
				
                
                scene.obstacles = [];
				scene.obstacles.push(
					new Obstacle(new THREE.Vector3(50, 0, 50), 15)
				);
				scene.obstacles.push(
					new Obstacle(new THREE.Vector3(-70, 0, 40), 15)
				);
				scene.obstacles.push(
					new Obstacle(new THREE.Vector3(0, 0, -60), 15)
				);
				scene.obstacles[0].mesh.name = "obstacles";
				scene.obstacles[1].mesh.name = "obstacles";
				scene.obstacles[2].mesh.name = "obstacles";
				pickables2.push(
					flag,
					scene.obstacles[0].mesh,
					scene.obstacles[1].mesh,
					scene.obstacles[2].mesh,
					soldier.mesh.children[2]
				);
				///////////////////////////////////////////////////////////

				nextTargetCircle = new THREE.Mesh(
					new THREE.CircleGeometry(3, 20),
					new THREE.MeshBasicMaterial({ color: "black" })
				);
				scene.add(nextTargetCircle);
				nextTargetCircle.rotation.x = -Math.PI / 2;
				nextTargetCircle.position.set(2000, 0, 0);
				
				//戰士移動
				power = 5.0;
				angle = 0.0;
				
				hudScene = new THREE.Scene();
				hudScene.add (new THREE.Mesh (new THREE.RingGeometry(12,15,30), new THREE.MeshBasicMaterial({color:'black'})));
				hudScene.add (makeCross());
				hudCamera = new THREE.OrthographicCamera (-20,20,20,-20,-10,10);
				
				initHUD();
			}
			function DefMesh() {
				let loader = new THREE.TextureLoader();
				let icon = loader.load("https://i.imgur.com/iiq8Wk5.png");

				let loaderBody = new THREE.TextureLoader();
				let iconBody = loader.load("https://i.imgur.com/iiq8Wk5.png");
				iconBody.wrapS = THREE.RepeatWrapping;
				iconBody.wrapT = THREE.RepeatWrapping;
				iconBody.repeat.set(5, 1);

				var def = new THREE.Group();
				var mat = new THREE.MeshNormalMaterial();

				var body = new THREE.Mesh(
					new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
					new THREE.MeshBasicMaterial({ 
						color: "lightgreen",
						map: iconBody,
						side: THREE.DoubleSide,
					})
				);
				var body2 = new THREE.Mesh(
					new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
					new THREE.MeshBasicMaterial({ 
						color: "red",
						map: iconBody,
						side: THREE.DoubleSide,
					})
				);

				var pointer = new THREE.Mesh(
					new THREE.BoxGeometry(15, 2, 2),
					mat
				);
				body.position.y = 2;
				body2.position.y = 2;
				pointer.position.set(5, 2, 0);

				// '卒'蓋
				let iconZX = new THREE.Group();
				let circle = new THREE.Mesh(
					new THREE.CircleGeometry(8, 32),
					new THREE.MeshBasicMaterial({ map: icon })
				);
				circle.position.y = 4;
				circle.rotation.x = -Math.PI / 2;
				iconZX.add(circle);

				def.add(body, body2, iconZX, pointer);
				return def;
			}

			function soldierMesh() {
				let loader = new THREE.TextureLoader();
				let icon = loader.load("https://i.imgur.com/7yl0PLz.png");
				let loaderBody = new THREE.TextureLoader();
				let iconBody = loader.load("https://i.imgur.com/7yl0PLz.png");
				iconBody.wrapS = THREE.RepeatWrapping;
				iconBody.wrapT = THREE.RepeatWrapping;
				iconBody.repeat.set(5, 1);
				var soldier = new THREE.Group();
				var mat = new THREE.MeshBasicMaterial({
					map: iconBody,
					side: THREE.DoubleSide,
				});
				var body = new THREE.Mesh(
					new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
					mat
				);
				var pointer = new THREE.Mesh(
					new THREE.BoxGeometry(15, 2, 2),
					new THREE.MeshNormalMaterial()
				);
				body.position.y = 2;
				body.name = "soldierBody";
				pointer.position.set(5, 2, 0);

				// '帥'蓋
				let iconZX = new THREE.Group();
				let circle = new THREE.Mesh(
					new THREE.CircleGeometry(8, 8),
					new THREE.MeshBasicMaterial({ map: icon })
				);
				circle.position.y = 4;
				circle.rotation.x = -Math.PI / 2;
				iconZX.add(circle);
				
				solattack = new THREE.Object3D();
				solattack.position.set(5,2,0);
				solattack2 = new THREE.Object3D();
				solattack2.position.set(4,2,0);

				soldier.add(iconZX, pointer, body,solattack,solattack2);
				return soldier;
			}
			function preditorMesh() {
				let loader = new THREE.TextureLoader();
				let icon = loader.load("https://i.imgur.com/9N9ohZ9.jpeg");
				let loaderBody = new THREE.TextureLoader();
				let iconBody = loader.load("https://i.imgur.com/9N9ohZ9.jpeg");
				iconBody.wrapS = THREE.RepeatWrapping;
				iconBody.wrapT = THREE.RepeatWrapping;
				iconBody.repeat.set(5, 1);
				
				
				var mat = new THREE.MeshNormalMaterial();
				var captain = new THREE.Group();
				var body = new THREE.Mesh(
					new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
					new THREE.MeshBasicMaterial({ 
						color: "lightgreen",
						map: iconBody,
						side: THREE.DoubleSide,
					})
				);
				var body2 = new THREE.Mesh(
					new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
					new THREE.MeshBasicMaterial({
						color: "red",
						map: iconBody,
						side: THREE.DoubleSide,
					})
				);
				var body3 = new THREE.Mesh(
					new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
					new THREE.MeshBasicMaterial({
						color: "yellow",
						map: iconBody,
						side: THREE.DoubleSide,
					})
				);
				var pointer = new THREE.Mesh(
					new THREE.BoxGeometry(15, 2, 2),
					mat
				);
				body.position.y = 3;
				pointer.position.set(5, 2, 0);

				// '帥'蓋
				let iconZX = new THREE.Group();
				let circle = new THREE.Mesh(
					new THREE.CircleGeometry(8, 8),
					new THREE.MeshBasicMaterial({ map: icon })
				);
				circle.position.y = 5;
				circle.rotation.x = -Math.PI / 2;
				iconZX.add(circle);

				captain.add(body, body2, body3, iconZX, pointer);
				return captain;
			}
			function capturerMesh() {
				let loader = new THREE.TextureLoader();
				let icon = loader.load("https://i.imgur.com/MIvqfLQ.png");

				let loaderBody = new THREE.TextureLoader();
				let iconBody = loader.load("https://i.imgur.com/MIvqfLQ.png");
				iconBody.wrapS = THREE.RepeatWrapping;
				iconBody.wrapT = THREE.RepeatWrapping;
				iconBody.repeat.set(5, 1);

				var capturer = new THREE.Group();
				var mat = new THREE.MeshNormalMaterial();
				var body = new THREE.Mesh(
					new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
					new THREE.MeshBasicMaterial({
						color: "lightgreen",
						map: iconBody,
						side: THREE.DoubleSide,
					}) //snatch
				);
				var body2 = new THREE.Mesh(
					new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
					new THREE.MeshBasicMaterial({
						color: "yellow",
						map: iconBody,
						side: THREE.DoubleSide,
					}) //hide
				);
				var body3 = new THREE.Mesh(
					new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
					new THREE.MeshBasicMaterial({
						color: "blue",
						map: iconBody,
						side: THREE.DoubleSide,
					}) //touchDown
				);
				var body4 = new THREE.Mesh(
					new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
					new THREE.MeshBasicMaterial({
						color: "red",
						map: iconBody,
						side: THREE.DoubleSide,
					}) //endDown
				);
				var body5 = new THREE.Mesh(
					new THREE.CylinderGeometry(8, 8, 4, 20, 1, true),
					new THREE.MeshBasicMaterial({
						color: "green",
						map: iconBody,
						side: THREE.DoubleSide,
					}) //search
				);

				var pointer = new THREE.Mesh(
					new THREE.CylinderGeometry(1.5, 1.5, 15, 20, 1),
					mat
				);
				var pbody = new THREE.Mesh(
					new THREE.CylinderGeometry(1.6, 1.6, 1.5, 20, 1, true),
					new THREE.MeshBasicMaterial({
						color: "lightgreen",
						side: THREE.DoubleSide,
					})
				);
				var pbody2 = new THREE.Mesh(
					new THREE.CylinderGeometry(1.6, 1.6, 1.5, 20, 1, true),
					new THREE.MeshBasicMaterial({
						color: "yellow",
						side: THREE.DoubleSide,
					})
				);
				var pbody3 = new THREE.Mesh(
					new THREE.CylinderGeometry(1.6, 1.6, 1.5, 20, 1, true),
					new THREE.MeshBasicMaterial({
						color: "blue",
						side: THREE.DoubleSide,
					})
				);
				var pbody4 = new THREE.Mesh(
					new THREE.CylinderGeometry(1.6, 1.6, 1.5, 20, 1, true),
					new THREE.MeshBasicMaterial({
						color: "red",
						side: THREE.DoubleSide,
					})
				);
				var pbody5 = new THREE.Mesh(
					new THREE.CylinderGeometry(1.6, 1.6, 1.5, 20, 1, true),
					new THREE.MeshBasicMaterial({
						color: "0x1ad450",
						side: THREE.DoubleSide,
					})
				);

				var searchCircle = new THREE.Mesh(
					new THREE.CircleGeometry(75, 32),
					new THREE.MeshBasicMaterial({
						color: "pink",
						transparent: true,
						opacity: 0.4,
						side: THREE.DoubleSide,
					})
				);
				searchCircle.rotation.x = -Math.PI / 2;

				pbody.position.set(11, 2, 0);
				pbody.rotation.z = Math.PI / 2;
				pbody2.position.set(11, 2, 0);
				pbody2.rotation.z = Math.PI / 2;
				pbody3.position.set(11, 2, 0);
				pbody3.rotation.z = Math.PI / 2;
				pbody4.position.set(11, 2, 0);
				pbody4.rotation.z = Math.PI / 2;
				pbody5.position.set(11, 2, 0);
				pbody5.rotation.z = Math.PI / 2;
				body.position.y = 2;
				body2.position.y = 2;
				body3.position.y = 2;
				body4.position.y = 2;
				body5.position.y = 2;
				pointer.position.set(5, 2, 0);
				pointer.rotation.z = Math.PI / 2;

				// '車'蓋
				let iconZX = new THREE.Group();
				let circle = new THREE.Mesh(
					new THREE.CircleGeometry(8, 8),
					new THREE.MeshBasicMaterial({
						map: icon,
						color: "lightgreen",
						side: THREE.DoubleSide,
					}) //snatch
				);
				circle.position.y = 4;
				circle.rotation.x = -Math.PI / 2;
				let circle2 = new THREE.Mesh(
					new THREE.CircleGeometry(8, 8),
					new THREE.MeshBasicMaterial({
						map: icon,
						color: "yellow",
						side: THREE.DoubleSide,
					}) //hide
				);
				circle2.position.y = 4;
				circle2.rotation.x = -Math.PI / 2;
				let circle3 = new THREE.Mesh(
					new THREE.CircleGeometry(8, 8),
					new THREE.MeshBasicMaterial({
						map: icon,
						color: "blue",
						side: THREE.DoubleSide,
					}) //touchDown
				);
				circle3.position.y = 4;
				circle3.rotation.x = -Math.PI / 2;
				let circle4 = new THREE.Mesh(
					new THREE.CircleGeometry(8, 8),
					new THREE.MeshBasicMaterial({
						map: icon,
						color: 0x1ad450,
						side: THREE.DoubleSide,
					}) //touchDown
				);
				circle4.position.y = 4;
				circle4.rotation.x = -Math.PI / 2;
				iconZX.add(circle, circle2, circle3, circle4);

				capturer.add(
					iconZX,
					pointer,
					body,
					body2,
					body3,
					body4,
					body5,
					pbody,
					pbody2,
					pbody3,
					pbody4,
					pbody5,
					searchCircle
				);
				return capturer;
			}
		  function stateSign() {
				let loader = new THREE.TextureLoader();
				let snatchMap = loader.load("https://i.imgur.com/L67LiqY.png");
				let searchMap = loader.load("https://i.imgur.com/ui0cEeC.png");
				let hideMap = loader.load("https://i.imgur.com/BRChBw1.png");
				let touchDownMap = loader.load(
					"https://i.imgur.com/lJ95E9L.png"
				);
				let snatchMesh = new THREE.Mesh(
					new THREE.PlaneGeometry(35, 30),
					new THREE.MeshBasicMaterial({
						map: snatchMap,
						transparent: true,
						alphaTest: 0,
						side: THREE.DoubleSide,
					})
				);
				let searchMesh = new THREE.Mesh(
					new THREE.PlaneGeometry(35, 20),
					new THREE.MeshBasicMaterial({
						map: searchMap,
						transparent: true,
						alphaTest: 0,
						side: THREE.DoubleSide,
					})
				);
				let hideMesh = new THREE.Mesh(
					new THREE.PlaneGeometry(35, 30),
					new THREE.MeshBasicMaterial({
						map: hideMap,
						transparent: true,
						alphaTest: 0,
						side: THREE.DoubleSide,
					})
				);
				let touchDownMesh = new THREE.Mesh(
					new THREE.PlaneGeometry(50, 30),
					new THREE.MeshBasicMaterial({
						map: touchDownMap,
						transparent: true,
						alphaTest: 0,
						side: THREE.DoubleSide,
					})
				);
				let preyStateSign = new THREE.Group();
				preyStateSign.add(
					snatchMesh,
					searchMesh,
					hideMesh,
					touchDownMesh
				);
				return preyStateSign;
			}
			function onDocumentMouseDown(event) {
				event.preventDefault();
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

				raycaster.setFromCamera(mouse, camera);

				var intersects = raycaster.intersectObjects(pickables);
				if (intersects.length > 0) {
					//target.position.copy(intersects[0].point);
					flag.position.copy(intersects[0].point);
					flag.position.y = 8;
				}
			}
			function sight(dst) {
				if (dst < 150 && front === true) {
					prey.fsm.seeFlag();
				}
				if (dst >= 150 && front === false) {
					prey.fsm.findFlag();
				}
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}
			function checkRaycaster() {
				let preditorToTarget = soldier.pos.clone().sub(preditor.pos);
				let preditorDir = preditor.mesh
					.localToWorld(new THREE.Vector3(1, 0, 0))
					.sub(preditor.mesh.localToWorld(new THREE.Vector3(0, 0, 0)))
					.normalize();
				preditorRaycaster.set(preditor.pos, preditorDir);

				let preditordistance = preditor.pos.distanceTo(soldier.pos);

				if (
					(preditorToTarget.dot(preditorDir) > 0 &&
						preditordistance < 60) ||
					attack == true
				) {
					preditor.fsm.shoot();
					$("#inView").text("soldier in view");
				} else {
					preditor.fsm.depart();
					$("#inView").text("soldier NOT in view");
				}
			}
			function randomPosZX(min, max) {
				let x = min + (max - min) * Math.random();
				let z = min + (max - min) * Math.random();

				return new THREE.Vector3(x, 0, z); //x,0,z);
			}
			function findDis(a, b) {
				return a.pos.distanceTo(b.position);
			}

			function nearObstacle() {
				var minDis = findDis(prey, scene.obstacles[0].mesh);
				var minNum = 0;

				for (var i = 1; i < scene.obstacles.length; i++) {
					var dis = findDis(prey, scene.obstacles[i].mesh);
					if (dis < minDis) {
						minDis = dis;
						minNum = i;
					}
				}
				return scene.obstacles[minNum];
			}

			function findP(c) {
				var axis = new THREE.Vector3(0, 1, 0);
				var cp = new THREE.Vector3();
				var csDis = c.position.distanceTo(soldier.pos);
				var theta;
				var r = nearObstacle().size;
				theta = Math.acos(r / csDis);
				var cs = new THREE.Vector3();
				cs.subVectors(c.position, soldier.pos);
				cp = cs.setLength(r);
				cp.applyAxisAngle(axis, theta);
				var p = new THREE.Vector3();
				p.subVectors(c.position, cp);

				/*circleL.rotation.x = -Math.PI / 2;
				circleL.position.set(p.x, 0, p.z);*/
				return p;
			}
			function findP1(c) {
				var axis = new THREE.Vector3(0, 1, 0);
				var cp1 = new THREE.Vector3();
				var csDis = c.position.distanceTo(soldier.pos);
				var theta;
				var r = nearObstacle().size;
				theta = Math.acos(r / csDis);
				var cs = new THREE.Vector3();
				cs.subVectors(c.position, soldier.pos);
				cp1 = cs.setLength(r);
				cp1.applyAxisAngle(axis, -theta);
				var p1 = new THREE.Vector3();
				p1.subVectors(c.position, cp1);

				/*circleR.rotation.x = -Math.PI / 2;
				circleR.position.set(p1.x, 0, p1.z);*/
				return p1;
			}
			function findHidePlace(c, p) {
				var alpha, theta;
				var csDis = c.position.distanceTo(soldier.pos);
				var r = nearObstacle().size;
				theta = Math.acos(r / csDis);
				var psDis = p.distanceTo(soldier.pos);

				var cs = new THREE.Vector3();
				cs.subVectors(c.position, soldier.pos);

				alpha = Math.atan2(cs.z, cs.x);
				pAngle = alpha + theta;
				p1Angle = alpha - theta;
				if (pAngle < 0) {
					pAngle + 2 * Math.PI;
				}
				if (p1Angle < 0) {
					p1Angle + 2 * Math.PI;
				}
			}
            setInterval(function () {
				clock.elapsedTime = 0;
				//count = Math.random();
			}, Math.random() * 1000 + 5000);
			setInterval(function () {
				//console.log(second);
				if (already > -1) second = 0;
				else second += 1;
			}, 1000);
			
			
			function loadCubemap() {
				var urls = [
					"https://i.imgur.com/BTTaDij.png", //posx
					"https://i.imgur.com/OkJtYZc.png", //negx
					"https://i.imgur.com/0tGuYpX.png", //posy
					"https://i.imgur.com/TC89KdS.png", //negy
					"https://i.imgur.com/nlwQLOA.png", //posz
					"https://i.imgur.com/7vvbkjE.png", //negz
				];
				var loader = new THREE.CubeTextureLoader();
				loader.setCrossOrigin("");
				var cubeMap = loader.load(urls);
				cubeMap.format = THREE.RGBFormat;
				return cubeMap;
			}
			
			/////瞄準
			function makeCross() {
				let cross = new THREE.Group();

				let points = [
					new THREE.Vector3(-12, 0, 0),
					new THREE.Vector3(12, 0, 0)
				];

				let geometry0 = new THREE.BufferGeometry();
				geometry0.setFromPoints(points);
				let line0 = new THREE.Line(
					geometry0,
					new THREE.LineBasicMaterial({ color: "black" })
				);

				points = [
					new THREE.Vector3(0, -12, 0),
					new THREE.Vector3(0, 12, 0)
				];

				let geometry1 = new THREE.BufferGeometry();
				geometry1.setFromPoints(points);
				let line1 = new THREE.Line(
					geometry1,
					new THREE.LineBasicMaterial({ color: "black" })
				);

				cross.add(line0, line1);
				return cross;
			}
			
			
			/////士兵射擊
			function SoldierShooting(){
				if(keyboard.down('space')){
					count = 0; 
					let fire = true;
					count = count + 1;
					if(count < 2){
						const geometry = new THREE.SphereGeometry( 0.5, 32, 32 );
						const material = new THREE.MeshBasicMaterial({color : "yellow"});
						let bullet = new THREE.Mesh( geometry, material );
							solattack.getWorldPosition(bullet.position);

						let point = new THREE.Vector3();
							solattack2.getWorldPosition(point);

						scene.add(bullet);

						let direction = bullet.position.clone().sub(point).normalize(); //創造方向

						bullets.push({
							bullet: bullet,
							direction: direction,
						});
					}
					else{
						//$('#Check').text ('Out of Bullet !!!');
					}
					
				}
				//if(keyboard.pressed('z')){
					//count = 0;
					//$('#Check').text ('Filled Bullet !!!');
				//}
				
			}
			
			////射擊
			function ShootThrough(){

				let x = -1, y = -1;//,m = -1,n = -1;
				for(let i = 0; i < bullets.length; i++){
					
					
					let prePosition = bullets[i].bullet.position; 
					let nextPosition = bullets[i].bullet.position.clone().add(bullets[i].direction.clone().setLength(0.5)); 
					let C = prey.pos.clone().center;
					let R = prey.size;
					
					
					let dis = bullets[i].bullet.position.clone().sub(prey.pos).length();
					//let dis1 = bullets[i].bullet.position.clone().sub(prey1.pos).length();
						
					if(dis < 8){
						x = i;
						y = 0;
					 }
					 /*if(dis1 < 8){
						m = i;
						n = 0;
					 }*/
					 

					bullets[i].bullet.position.copy(nextPosition);
				}
				
				if(x !== -1 && y !== -1){
					scene.remove(bullets[x].bullet);

					bullets.splice(x,1);
				   // pickables.splice(y,1);
				   
				   /////血量//////
					Hp -= ATTACK;
					console.log(Hp);
					document.querySelector(".hp").style.width = `${Hp}%`;
						
					if(Hp == 0){
						lifeNum--;
						scene.remove(prey.mesh);
					}
					
					if(lifeNum == 3){
							
						document.getElementById("heart").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">  <img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">  <img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">';
					}
					else if(lifeNum == 2){
							
						document.getElementById("heart").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">  <img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">';
					}
					else if(lifeNum == 1){
							
							document.getElementById("heart").innerHTML = '<img src="https://i.imgur.com/gPrrPdn.png" width = "40" height = "40">';
					}
					else{
							document.getElementById("heart").innerHTML = 'You Die.';
							
					}
					
					
				}
				
			}
			function rebirth(inner,outside){
				let loaderPortal = new THREE.TextureLoader();
				loaderPortal.crossOrigin = "";
				let texture = loaderPortal.load(
					"https://i.imgur.com/u0tlqX2.png"
				);

				var texMat = new THREE.MeshBasicMaterial({
					map: texture,
					side: THREE.DoubleSide,
					alphaTest: 0.5,
				});
				respawnPos = new THREE.Mesh(
							new THREE.RingGeometry(inner, outside, 32), //8,18,32
							texMat
				);

				respawnPos.rotation.y = -Math.PI / 2;
				
				tunnel = new THREE.Mesh(new THREE.CylinderGeometry(13,13,8,32),
						new THREE.MeshBasicMaterial({
							color: 'white',
							transparent: true,
							opacity: 0.3,
							side: THREE.DoubleSide,
						})
				);
				tunnel.rotation.x = Math.PI/2;
				tunnel.position.set(0,0,4);
				//respawnPos.add(tunnel);
				
				return respawnPos;
				//respawnPos.position.set(-120, 17, -100);
			}
			function preydown(){
				prey.setSeekTarget(-170,0, -170);
				soldier.setSeekTarget(170,0,170);
			}

			function cancel(){
				scene.remove(rebir,rebir2);
			}
			function SoldierMoving(dt) {
		
				if(movevel.length() > 0){
					angle = 1.5*Math.PI + Math.atan2(movevel.x,movevel.z);
				}

				
				if (keyboard.pressed("up")) {
					power *= 1.2;
				}

				if (keyboard.pressed("down")) {
					power /= 1.2;
				}
				
				power = Math.clamp (power, 0, 80.0);
				
				var angle_thrust = angle;
				if (keyboard.pressed("left")) {
					 angle_thrust += 0.3;
				}
				if (keyboard.pressed("right")) {
					angle_thrust -= 0.3;
				}
				var thrust = new THREE.Vector3(1,0,0).multiplyScalar(power).applyAxisAngle (new THREE.Vector3(0,1,0), angle_thrust);
				moveforce.copy (thrust);
				moveforce.add(movevel.clone().multiplyScalar(-2))
				movevel.add(moveforce.clone().multiplyScalar(dt));
				movepos.add(movevel.clone().multiplyScalar(dt));

				if(keyboard.down("shift")){
					zoom = true;
					inHUD = true;

					soldier.mesh.add(camera);
					camera.position.copy(new THREE.Vector3(21,2,0));
					camera.lookAt(soldier.pos.clone().add(new THREE.Vector3(20,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), angle_thrust)).add(new THREE.Vector3(0,2,0)));
				}
				else if(keyboard.up("shift")){
					inHUD = false;
					zoom = false;

					soldier.mesh.remove(camera);
					camera.position.set(0,120,100);
					camera.lookAt(new THREE.Vector3(0,0,0));
				}

					camera.updateProjectionMatrix();
			}

			function restartgame() {
				state = -1;
				end.innerHTML = " ";
				restart.innerHTML = " ";
				
				
				start = document.getElementById("start");
				start.innerHTML = "Press enter to begin";
				

				insert = false;
				theta = 0;
				HH = 12;
				hide = false;
				stop = false;
				front = false;
				hidden = false;
				count = 0;
				get = false;
				attack = false;
                can = false;
                seeWarrior = false,seeCapturer = false;
                soldierFlag = false;
                second = 0;
                already = 1;

				var x = Math.random() * 380 - 190;
				flag.position.set(x, 8, -x);

				let dt = clock.getDelta();
				prey.pos.set(-175, 0, -175);
				prey.update(dt, time);
				prey.fsm.restart();
				
				
			}

			function animate() {
				animate.distance = animate.distance ? animate.distance : 0;
				//requestAnimationFrame(animate);

				let dt = clock.getDelta();
				time = clock.getElapsedTime();
                
				keyboard.update();
				//preditor.update(dt);
				prey.update(dt, time);
				//checkRaycaster();
				
				SoldierShooting();
				ShootThrough();
				//checkAim();

				/*agents.forEach(function (agent) {
					defenseR.update(dt);
					defense.update(dt);
					defenseL.update(dt);
				});*/

				soldier.update(dt);
				//hiddenOrNot();
				prey.findTarget(flag);
				soldier.findTarget();
				var dst = prey.pos.distanceTo(flag.position);
				var disToSoldier = prey.pos.distanceTo(soldier.pos);

				

				var c = new THREE.Mesh();
				c.position.set(
					nearObstacle().mesh.position.x,
					0,
					nearObstacle().mesh.position.z
				);

				var point = new THREE.Mesh();
				point.position.set(175, 0, 175);
				//console.log(second);
				if (
					Math.abs(soldier.pos.x - flag.position.x) < 5 &&
					Math.abs(soldier.pos.z - flag.position.z) < 5 &&
					get === false &&
					insert === false &&
					end === false
				) {
					flag.position.set(soldier.pos.x, 10, soldier.pos.z);
					soldierFlag = true;
				} else {
					soldierFlag = false;
				}

				if (soldierFlag === false) {
					if (
						disToSoldier < 75 &&
						seeWarrior === true &&
						seeCapturer === true
					) {
						already -= 1;

						get = false;
						attack = true;
						prey.fsm.attacked();

						var p = findP(c);
						findHidePlace(c, p);
					} else if (second > 8 || attack === false) {
						already = 1;

						attack = false;
						if (get === true || insert === true) {
							prey.fsm.takeFlag();
						} else if (dst < 75 /*&& front === true*/) {
							prey.fsm.seeFlag();
						} else {
							/*if (dst >= 200 && front === false && get === false) */
							prey.fsm.findFlag();
						}
					}
				}
				if (soldierFlag === true) {
					prey.fsm.defense();
				}
				if (
					Math.abs(prey.pos.x - point.position.x) < 5 &&
					Math.abs(prey.pos.z - point.position.z) < 5 &&
					insert === true &&
					get === true
				) {
					end = true;
					prey.setBrake(10);
				}

                
				animate.distance = dst;
                
                bullets.forEach(function(data){
					data.bullet.position.add(data.direction.clone().setLength(1));
				});
                rebir.rotation.z += 0.05;
				rebir2.rotation.z += 0.05;
				
				//Flag
				let cameraRoot = camera.position.clone();
				cameraRoot.y = 0;
				flag.lookAt(cameraRoot);
				
//////////////soldierMove
				SoldierMoving(dt);
				soldier.pos.copy(movepos);
				soldier.mesh.rotation.y = angle;
				
				//玩家視角(帥)
				if(isSwitch){
					soldier.mesh.children[0].rotation.y = -Math.PI/2;
					let cameraPos = new THREE.Vector3(-50,30,0);
					soldier.mesh.children[1].localToWorld (cameraPos);
					camera.position.copy (cameraPos);
					let cameraLookAt = new THREE.Vector3(0,10,0);
					soldier.mesh.children[1].localToWorld (cameraLookAt);
					camera.lookAt (cameraLookAt);
				}

				if (state === -1) {
					prey.setBrake(10);
					//prey.fsm.restart();
					
					prey.pos.set(-200, 20, -170);
					prey.setSeekTarget(-170,20, -170);
					setTimeout(preydown,500);
				
					soldier.pos.set(200,20, 170);
					soldier.setSeekTarget(170,20, 170);
					
					/*preditor.pos.set(-200,20, -170);
					defense.pos.set(-200,20, -170);
					defenseL.pos.set(-200,20, -170);
					defenseR.pos.set(-200,20, -170);
					*/
					
				}

				if (state === 0) {
					start.innerHTML = "";
					prey.findTarget(flag);
					//scene.add(rebir,rebir2);
					setTimeout(cancel,3000);
				}
				if (keyboard.down("enter") && state === -1) {
					state = 0;
				}

				if (prey.fsm.state === "touchDown" && flag.position.x >= 175) {
					end.innerHTML = "You lose.";
					restart.innerHTML = "Press enter to restart.";
					state = -2;
				}
				if (keyboard.down("enter") && state === -2) {
					scene.add(rebir,rebir2);
					restartgame();
				}
				
				/////血量//////
				if(Hp == 0){
					if(lifeNum != 0){
						Hp = 100;
						document.querySelector(".hp").style.width = `${Hp}%`;
						
						
						scene.add(rebir);
						rebir.position.set(-175,20,-170);
						scene.add(prey.mesh);
						
						prey.pos = rebir.position.clone();
						setTimeout(cancel,3000);
						
						
					}
					
				}
				
				// 讓「帥蓋」方位永遠固定
				if(!isSwitch){
					soldier.mesh.children[0].quaternion.copy(
						soldier.mesh.quaternion.clone().invert()
					);
				}
				// 讓「車蓋」方位永遠固定
				prey.mesh.children[0].quaternion.copy(
					prey.mesh.quaternion.clone().invert()
				);
				/*preditor.mesh.children[3].quaternion.copy(
					preditor.mesh.quaternion.clone().invert()
				);
				defense.mesh.children[2].quaternion.copy(
					defense.mesh.quaternion.clone().invert()
				);
				defenseR.mesh.children[2].quaternion.copy(
					defenseR.mesh.quaternion.clone().invert()
				);
				defenseL.mesh.children[2].quaternion.copy(
					defenseL.mesh.quaternion.clone().invert()
				);

				if (defenseR.fsm.state === "follow" && stop === true) {
					defenseR.fsm.attack();
					defense.fsm.attack();
					defenseL.fsm.attack();
				}
				if (defenseR.fsm.state === "defense" && stop === false) {
					defenseR.fsm.noattack();
					defense.fsm.noattack();
					defenseL.fsm.noattack();
				}*/
				
				/*
				renderer.clear(true);
				renderer.render(scene, camera);
				if(zoom)
					renderer.render (hudScene, hudCamera); 
				
				*/
				//render2();
				render();
			
				requestAnimationFrame( animate ); 
				
				
				
			}
			
			function render() {

					var WW = window.innerWidth;
					var HH = window.innerHeight;
					renderer.setScissorTest( true );

					renderer.setViewport(0, 0, WW, HH);
					camera.aspect = WW / HH;
					camera.updateProjectionMatrix();
					
					renderer.setScissor(0, 0, WW, HH);
					//renderer.clear();
					
					//renderer.setViewport(0, 0, WW/2, HH);
					//renderer.setScissor(0, 0, WW/2, HH);
					renderer.render(scene, camera);
					if(zoom)
						renderer1.render (hudScene, hudCamera); 
					renderer.setViewport(WW / 25, HH/2  , WW / 4, HH / 2);
					renderer.setScissor(WW / 25, HH/2 , WW / 4, HH / 2);
					
					renderer.clear(true);  // important!
					
					renderer.render(sceneHUD, cameraHUD1);		// border
					renderer.render(scene, cameraHUD2);
					
					
				
					renderer.setScissorTest( false );
			}
			function render2() {

					var WW = window.innerWidth;
					var HH = window.innerHeight;
					renderer1.setScissorTest( true );

					renderer1.setViewport(0, 0, WW, HH);
					camera.aspect = WW / HH;
					camera.updateProjectionMatrix();
					
					renderer1.setScissor(0, 0, WW, HH);
					//renderer.clear();
					
					//renderer.setViewport(0, 0, WW/2, HH);
					//renderer.setScissor(0, 0, WW/2, HH);
					renderer1.render(scene, camera);
					renderer1.setViewport(WW / 25, HH/2  , WW / 4, HH / 2);
					renderer1.setScissor(WW / 25, HH/2 , WW / 4, HH / 2);
					
					renderer1.clear(true);  // important!
					if(zoom)
						renderer1.render (hudScene, hudCamera); 
					renderer.render(scene, cameraHUD2);
						
					renderer1.setScissorTest( false );
			}
			
		</script>
	</body>
</html>